var documenterSearchIndex = {"docs":
[{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"EditURL = \"<unknown>/literate/joints.jl\"","category":"page"},{"location":"manual/joints/#Joints-and-body-joint-systems","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"","category":"section"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"CurrentModule = RigidBodyTools","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"For systems consisting of one or more rigid bodies, joints are used to specify the degrees of freedom permitted for the body. Even for a single rigid body, the body is assumed to be connected by a joint with the inertial coordinate system.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"In three dimensions, there are several different classes of joint:","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"RevoluteJoint, which rotates about an axis and has only one degree of freedom\nPrismaticJoint, which slides along one axis and has only one degree of freedom\nHelicalJoint, which rotates about and slides along one axis (two degrees of freedom)\nSphericalJoint, which rotates freely about one point (three degrees of freedom)\nFreeJoint, which can move in any manner (six degrees of freedom)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"However, in two spatial dimensions, there are only two","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"RevoluteJoint (one degree of freedom: rotation)\nFreeJoint2d (three degrees of freedom: rotation, two translation)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"using RigidBodyTools\nusing Plots","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"A joint serves as a connection between two bodies; one of the bodies is the parent and the other is the child. It is also common for a body to be connected to the inertial coordinate system, in which case the inertial system is the parent and the body is the child. The user must specify the id of the parent body and the child body. The id of the inertial system is 0.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Before we discuss how a joint is specified, it is important to understand that a joint is basically just an intermediate MotionTransform from the parent body's system to the child body's system.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"That is, to construct the transform from body P to body C, we would compose it as follows","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"^C X_P = ^CX_J(C) ^J(C)X_J(P) ^J(P)X_P","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"The transform in the middle is the joint transform and is the only one of these that can vary in time. It maps from one coordinate system attached (rididly) to the parent body to another coordinate system attached (rigidly) to the child body.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"The degrees of freedom of the joint constrain the behavior of this joint transform. Below, we show how joints are constructed and used.","category":"page"},{"location":"manual/joints/#Joint-construction-generalities","page":"Joints and body-joint systems","title":"Joint construction generalities","text":"","category":"section"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"The user must specify where the joint is located on each body, relative to the origin of the body's coordinate system, and what orientation the joint takes with respect to the body's coordinate system. These are specified with MotionTransforms, transforming from each body's coordinate system to the joint's coordinate system on that body. This transform is invariant – it never changes.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Also, the user must specify the behavior of each of the degrees of freedom of a joint, using the tools we discussed in the previous page.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"The basic signature is","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Joint(joint_type,parent_body_id,Xp_to_jp,child_body_id,Xc_to_jc,doflist)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"However, there is a specialized signature if you simply wish to place a body in some stationary configuration X:","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Joint(X,body_id)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"and if there is only one body and it is stationary, then","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Joint(X)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"will do.","category":"page"},{"location":"manual/joints/#Example","page":"Joints and body-joint systems","title":"Example","text":"","category":"section"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Let's see a 2d example. Suppose we have two bodies, 1 and 2. Body 1 is to be connected to the inertial coordinate system, and prescribed with motion that causes it to oscillate rotationally (pitch) about a point located at (-10) and in the body's coordinate system, and this pitch axis can oscillate up and down (heave).","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Body 2 is to be connected by a hinge to body 1, and this hinge's angle will also oscillate. We will set the hinge to be located at (1020) on body 1 and (-1020) on body 2.","category":"page"},{"location":"manual/joints/#Joint-from-inertial-system-to-body-1","page":"Joints and body-joint systems","title":"Joint from inertial system to body 1","text":"","category":"section"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"First, let's construct the joint from the inertial system to body 1. This should be a FreeJoint2d, since motion is prescribed in two of the three degrees of freedom (as well as the third one, with zero velocity). We can assume that the joint is attached to the origin of the parent (the inertial system). On the child (body 1), the joint is to be at [-1,0].","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"pid = 0\nXp_to_jp = MotionTransform([0,0],0)\ncid = 1\nXc_to_jc = MotionTransform([-1,0],0)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"For the rotational and the y degrees of freedom, we need oscillatory motion. For the rotational motion, let's set the amplitude to pi4 and the angular frequency to Omega = 2pi, but set the phase and mean velocity both to zero.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Ar = π/4\nΩ = 2π\nϕr = 0.0\nvel = 0.0\nkr = OscillatoryDOF(Ar,Ω,ϕr,vel)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"For the plunging, we will set an amplitude of 1 and a phase lag of pi2, but keep the same frequency as the pitching.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Ay = 1\nϕy = -π/2\nky = OscillatoryDOF(Ay,Ω,ϕy,vel)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"The x degree of freedom is simply constant velocity, set to 0, to ensure it does not move in the x direction.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"kx = ConstantVelocityDOF(0)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"We put these together into a vector, to pass along to the joint constructor. The ordering of these in the vector is important. It must be [rotational, x, y].","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"dofs = [kr,kx,ky];\nnothing #hide","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Now set the joint","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"joint1 = Joint(FreeJoint2d,pid,Xp_to_jp,cid,Xc_to_jc,dofs)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Note that this joint has three constrained degrees of freedom, no exogenous degrees of freedom, and no unconstrained degrees of freedom. In a later example, we will change this.","category":"page"},{"location":"manual/joints/#Joint-from-body-1-to-body-2","page":"Joints and body-joint systems","title":"Joint from body 1 to body 2","text":"","category":"section"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"This joint is a RevoluteJoint. First set the joint locations on each body.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"pid = 1\nXp_to_jp = MotionTransform([1.02,0],0)\ncid = 2\nXc_to_jc = MotionTransform([-1.02,0],0)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Now set its single degree of freedom (rotation) to have oscillatory kinematics. We will set its amplitude the same as before, but give it a phase lag","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Ar = π/4\nΩ = 2π\nϕr = -π/4\nkr = OscillatoryDOF(Ar,Ω,ϕr,vel)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Put it in a one-element vector.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"dofs = [kr];\nnothing #hide","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"and construct the joint","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"joint2 = Joint(RevoluteJoint,pid,Xp_to_jp,cid,Xc_to_jc,dofs)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Group the two joints together into a vector. It doesn't matter what order this vector is in, since the connectivity will be figured out any way it is ordered, but it numbers the joints by the order they are provided here.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"joints = [joint1,joint2];\nnothing #hide","category":"page"},{"location":"manual/joints/#Assembling-the-joints-and-bodies","page":"Joints and body-joint systems","title":"Assembling the joints and bodies","text":"","category":"section"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"The joints and bodies comprise an overall RigidBodyMotion system. When this system is constructed, all of the connectivities are determined (or missing connectivities are revealed). The construction requires that we have set up the bodies themselves, so let's do that first. We will make both body 1 and body 2 an ellipse of aspect ratio 5. Note that ordering of bodies matters here, because the first in the list is interpreted as body 1, etc.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"b1 = Ellipse(1.0,0.2,0.02)\nb2 = Ellipse(1.0,0.2,0.02)\nbodies = BodyList([b1,b2])","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Now we can construct the system","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"ls = RigidBodyMotion(joints,bodies)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Before we proceed, it is useful to demonstrate some of the tools we have to probe the connectivity of the system. For example, to find the parent joint of body 1, we use","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"parent_joint_of_body(1,ls)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"This returns 1, since we have connected body 1 to joint 1. How about the child joint of body 1? We expect it to be 2. Since there might be more than one child, this returns a vector:","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"child_joints_of_body(1,ls)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"We can also check the body connectivity of joints. This can be very useful for more complicated systems in which the joint numbering is less clear. The parent body of joint 1","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"parent_body_of_joint(1,ls)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"This returns 0 since we have connected joint 1 to the inertial system. The child body of joint 2:","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"child_body_of_joint(2,ls)","category":"page"},{"location":"manual/joints/#The-system-state-vector","page":"Joints and body-joint systems","title":"The system state vector","text":"","category":"section"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"A key concept in advancing, plotting, and doing further analysis of this system of joints and bodies is the state vector, x. This state vector has entries for the position of every degree of freedom of all of the joints. It also may have further entries for other quantities that need to be advanced, but for this example, there are no other entries.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"There are two functions that are useful for constructing the state vector. The first is zero_motion_state, which simply creates a vector of zeros of the correct size.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"zero_motion_state(bodies,ls)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"The second is init_motion_state, which fills in initial position values for any degrees of freedom that have been prescribed.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"x = init_motion_state(bodies,ls)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Note that neither of these functions has any mutating effect on the arguments (bodies and ls).","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Also, it is always possible for the user to modify the entries in the state vector after this function is called. In general, it would be difficult to determine which entry is which in this state vector, so we can use a special function for this. For example, to get access to just the part of the state vector for the positions of joint 1,","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"jid = 1\nx1 = position_vector(x,ls,jid)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"This is a view on the overall state vector. This, if you decide to change an entry of x1, this, in turn, would change the correct entry in x.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"We can use the system state vector to put the bodies in their proper places, using the joint positions in x.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"update_body!(bodies,x,ls)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Let's plot this just to check","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"plot(bodies,xlims=(-4,4),ylims=(-4,4))","category":"page"},{"location":"manual/joints/#Advancing-the-state-vector","page":"Joints and body-joint systems","title":"Advancing the state vector","text":"","category":"section"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Once the initial state vector is constructed, then the system can be advanced in time. In this example, there are no exogenous or unconstrained degrees of freedom that require extra input, so the system is closed as it is. To advance the system, we need to solve the system of equations fracmathrmdxmathrmdt = f(xt)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"The function f(xt) describing the rate of change of x is given by the function motion_rhs!. This function mutates its first argument, the rate-of-change vector dxdt, which can then be used to update the state. The system and bodies are passed in as a tuple, followed by time.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Using a simple forward Euler method, the state vector can be advanced as follows","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"t0, x0 = 0.0, init_motion_state(bodies,ls)\ndxdt = zero(x0)\nx = copy(x0)\ndt, tmax = 0.01, 4.0\nfor t in t0:dt:t0+tmax\n  motion_rhs!(dxdt,x,(ls,bodies),t)\n  global x += dxdt*dt\nend","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Now that we know how to advance the state vector, let's create a macro that can be used to make a movie of the evolving system.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"macro animate_motion(b,m,dt,tmax,xlim,ylim)\n    return esc(quote\n            bc = deepcopy($b)\n            t0, x0 = 0.0, init_motion_state(bc,$m)\n            dxdt = zero(x0)\n            x = copy(x0)\n\n            @gif for t in t0:$dt:t0+$tmax\n                motion_rhs!(dxdt,x,($m,bc),t)\n                global x += dxdt*$dt\n                update_body!(bc,x,$m)\n                plot(bc,xlims=$xlim,ylims=$ylim)\n            end every 5\n        end)\nend","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Let's use it here","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"@animate_motion bodies ls 0.01 4 (-4,4) (-4,4)","category":"page"},{"location":"manual/joints/#Outputting-the-surface-velocities","page":"Joints and body-joint systems","title":"Outputting the surface velocities","text":"","category":"section"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"For use in mechanics problems, it is important to be able to output the velocity of the points on the surface of bodies at a given system state and time. We use the function surface_velocity! for this.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"First, initialize vectors for the u and v components in this 2d example, using the zero_body function.","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"u, v = zero_body(bodies), zero_body(bodies)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Now evaluate the velocities at time 0, with the initial state","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"surface_velocity!(u,v,bodies,x0,ls,t0)","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"We can plot these on each body using the view function for BodyList. For example, the vector of u velocities on body 2 is","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"plot(view(u,bodies,2))","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"In this use of surface_velocities!, we outputted the velocities in inertial coordinates. There is a keyword axes that allows us to relax this. By default, this is set to :inertial. However, we can also output them in their own body coordinates with the keyword axes=:body,","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"surface_velocity!(u,v,bodies,x0,ls,t0;axes=:body)\nplot(view(u,bodies,2))","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"We can also select only to evaluate a part of the body's motion on the surface points, using the motion_part keyword. This keyword defaults to :full, but we can also select :angular or :linear:","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"surface_velocity!(u,v,bodies,x0,ls,t0;axes=:body,motion_part=:angular)\nplot(view(u,bodies,2))","category":"page"},{"location":"manual/joints/#Joint-functions","page":"Joints and body-joint systems","title":"Joint functions","text":"","category":"section"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"Joint\nzero_joint\ninit_joint","category":"page"},{"location":"manual/joints/#RigidBodyTools.Joint","page":"Joints and body-joint systems","title":"RigidBodyTools.Joint","text":"Joint(jtype::AbstractJointType,parent_id,Xp_to_j::MotionTransform,child_id,Xch_to_j::MotionTransform,\n        dofs::Vector{AbstractDOFKinematics};[params=Dict()])\n\nConstruct a joint of type jtype, connecting parent body of id parent_id to child body of id child_id. The placement of the joint on the bodies is given by Xp_to_j and Xch_to_j, the transforms from the parent and child coordinate systems to the joint system, respectively. Each of the degrees of freedom for the joint is specified with dofs, a vector of AbstractDOFKinematics. Any parameters required by the joint can be passed along in the optional params dictionary.\n\n\n\n\n\nJoint(X::MotionTransform,bid::Int)\n\nConstruct a joint that simply places the body with ID bid rigidly in the configuration given by X.\n\n\n\n\n\nJoint(X::MotionTransform)\n\nFor a problem with a single body, construct a joint that simply places the body rigidly in the configuration given by X.\n\n\n\n\n\n","category":"type"},{"location":"manual/joints/#RigidBodyTools.zero_joint","page":"Joints and body-joint systems","title":"RigidBodyTools.zero_joint","text":"zero_joint(joint::Joint[;dimfcn=position_and_vel_dimension])\n\nCreate a vector of zeros for different aspects of the joint state, based on the argument dimfcn. By default, it uses position_and_vel_dimension and creates a zero vector sized according to the the position of the joint and the parts of the joint velocity that must be advanced (from acceleration). Alternatively, one can use position_dimension, constrained_dimension, unconstrained_dimension, or exogenous_dimension.\n\n\n\n\n\nzero_joint(ls::RigidBodyMotion[;dimfcn=position_and_vel_dimension])\n\nCreate a vector of zeros for some aspect of the state of the linked system(s) ls, based on the argument dimfcn. By default, it uses position_and_vel_dimension and creates a zero vector sized according to the state of the joint. Alternatively, one can use position_dimension, constrained_dimension, unconstrained_dimension, or exogenous_dimension.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.init_joint","page":"Joints and body-joint systems","title":"RigidBodyTools.init_joint","text":"init_joint(joint::Joint[;tinit=0.0])\n\nCreate an initial state vector for a joint. It initializes the joint's constrained degrees of freedom with their kinematics, evaluated at time tinit (equal to zero, by default). Other degrees of freedom (exogenous, unconstrained) are initialized to zero, so they can be set manually.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#System-and-state-functions","page":"Joints and body-joint systems","title":"System and state functions","text":"","category":"section"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"RigidBodyMotion\nzero_motion_state\ninit_motion_state\nBase.view(::AbstractVector,::RigidBodyMotion,::Int)\nposition_vector\nvelocity_vector\ndeformation_vector\nexogenous_position_vector\nexogenous_velocity_vector\nunconstrained_position_vector\nunconstrained_velocity_vector\nmotion_rhs!\nzero_exogenous\nupdate_exogenous!\nsurface_velocity!\nmaxvelocity\nismoving(::RigidBodyMotion)\nis_system_in_relative_motion","category":"page"},{"location":"manual/joints/#RigidBodyTools.RigidBodyMotion","page":"Joints and body-joint systems","title":"RigidBodyTools.RigidBodyMotion","text":"RigidBodyMotion\n\nType containing the connectivities and motions of rigid bodies, linked to the inertial system and possibly to each other, via joints. The basic constructor is RigidBodyMotion(joints::Vector{Joint},nbody::Int), in which joints contains a vector of joints of Joint type, each specifying the connection between a parent and a child body. (The parent may be the inertial coordinate system.)\n\n\n\n\n\n","category":"type"},{"location":"manual/joints/#RigidBodyTools.zero_motion_state","page":"Joints and body-joint systems","title":"RigidBodyTools.zero_motion_state","text":"zero_motion_state(bl::BodyList,ls::RigidBodyMotion)\n\nCreate a vector of zeros for the state of the linked system(s) ls.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.init_motion_state","page":"Joints and body-joint systems","title":"RigidBodyTools.init_motion_state","text":"init_motion_state(bl::BodyList,ls::RigidBodyMotion[;tinit = 0.0])\n\nInitialize the global linked system state vector, using the prescribed motions for constrained degrees of freedom to initialize the position components (evaluated at tinit, which by default is 0). The other degrees of freedom are initialized to zero, and can be set manually.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#Base.view-Tuple{AbstractVector, RigidBodyMotion, Int64}","page":"Joints and body-joint systems","title":"Base.view","text":"view(q::AbstractVector,ls::RigidBodyMotion,jid::Int[;dimfcn=position_dimension]) -> SubArray\n\nProvide a view of the range of values in vector q corresponding to the position of the joint with index jid in a RigidBodyMotion ls. The optional argument dimfcn can be set to position_dimension, constrained_dimension, unconstrained_dimension, or exogenous_dimension.\n\n\n\n\n\n","category":"method"},{"location":"manual/joints/#RigidBodyTools.position_vector","page":"Joints and body-joint systems","title":"RigidBodyTools.position_vector","text":"position_vector(x::AbstractVector,ls::RigidBodyMotion)\n\nReturns a view of the global state vector for a linked system containing only the position.\n\n\n\n\n\nposition_vector(x::AbstractVector,ls::RigidBodyMotion,jid::Int)\n\nReturns a view of the global state vector for a linked system containing only the position of joint jid.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.velocity_vector","page":"Joints and body-joint systems","title":"RigidBodyTools.velocity_vector","text":"velocity_vector(x::AbstractVector,ls::RigidBodyMotion)\n\nReturns a view of the global state vector for a linked system containing only the velocity.\n\n\n\n\n\nvelocity_vector(x::AbstractVector,ls::RigidBodyMotion,jid::Int)\n\nReturns a view of the global state vector for a linked system containing only the velocity of joint jid.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.deformation_vector","page":"Joints and body-joint systems","title":"RigidBodyTools.deformation_vector","text":"deformation_vector(x::AbstractVector,ls::RigidBodyMotion,bid::Int)\n\nReturns a view of the global state vector for a linked system containing only the body surface positions of the body with id bid.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.exogenous_position_vector","page":"Joints and body-joint systems","title":"RigidBodyTools.exogenous_position_vector","text":"exogenous_position_vector(x::AbstractVector,ls::RigidBodyMotion,jid::Int)\n\nReturns a view of the exogenous dof position(s), if any, of joint jid in the global state vector x.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.exogenous_velocity_vector","page":"Joints and body-joint systems","title":"RigidBodyTools.exogenous_velocity_vector","text":"exogenous_velocity_vector(x::AbstractVector,ls::RigidBodyMotion,jid::Int)\n\nReturns a view of the exogenous dof position(s), if any, of joint jid in the global state vector x.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.unconstrained_position_vector","page":"Joints and body-joint systems","title":"RigidBodyTools.unconstrained_position_vector","text":"unconstrained_position_vector(x::AbstractVector,ls::RigidBodyMotion,jid::Int)\n\nReturns a view of the unconstrained dof position(s), if any, of joint jid in the global state vector x.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.unconstrained_velocity_vector","page":"Joints and body-joint systems","title":"RigidBodyTools.unconstrained_velocity_vector","text":"unconstrained_velocity_vector(x::AbstractVector,ls::RigidBodyMotion,jid::Int)\n\nReturns a view of the unconstrained dof position(s), if any, of joint jid in the global state vector x.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.motion_rhs!","page":"Joints and body-joint systems","title":"RigidBodyTools.motion_rhs!","text":"motion_rhs!(dxdt::AbstractVector,x::AbstractVector,p::Tuple{RigidBodyMotion,BodyList},t::Real)\n\nSets the right-hand side vector dxdt (mutating) for linked system ls of bodies bl, using the current state vector x, the current time t.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.zero_exogenous","page":"Joints and body-joint systems","title":"RigidBodyTools.zero_exogenous","text":"zero_exogenous(ls::RigidBodyMotion)\n\nGenerate a zero vector of exogenous acclerations for system ls\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.update_exogenous!","page":"Joints and body-joint systems","title":"RigidBodyTools.update_exogenous!","text":"update_exogenous!(ls::RigidBodyMotion,a_edof::AbstractVector)\n\nMutates the exogenous buffer of ls with the supplied vector of exogenous accelerations a_edof. This function is useful for supplying time-varying exogenous values to the integrator from an outer loop.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.surface_velocity!","page":"Joints and body-joint systems","title":"RigidBodyTools.surface_velocity!","text":"surface_velocity!(u::AbstractVector,v::AbstractVector,bl::BodyList,x::AbstractVector,m::RigidBodyMotion,t::Real[;axes=:inertial,motion_part=:full])\n\nCalculate the surface velocity components u and v for the points on bodies bl. The function evaluates prescribed kinematics at time t and extracts non-prescribed (exogenous and unconstrained) velocities from state vector x. There are two Boolean keyword arguments that can change the behavior of this function: axes determines whether the components returned are expressed in the inertial coordinate system (:inertial, the default) or the body's own system (:body); motion_part determines whether the entire body velocity is used (:full, the default), only the angular part (:angular), or only the linear part (:linear).\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.maxvelocity","page":"Joints and body-joint systems","title":"RigidBodyTools.maxvelocity","text":"maxvelocity(b::Union{Body,BodyList},x::AbstractVector,m::RigidBodyMotion[,tmax=10,dt=0.05])\n\nSearch through the given motion state vector x and motion m applied to body b and return (umax,i,t,bid), the maximum velocity magnitude, the global index of the body point where it occurs, the time at which it occurs, and the body on which it occurs.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.is_system_in_relative_motion","page":"Joints and body-joint systems","title":"RigidBodyTools.is_system_in_relative_motion","text":"is_system_in_relative_motion(lsid::Int,ls::RigidBodyMotion) -> Bool\n\nReturns true if the linked system with ID lsid is in relative motion, i.e., if one or more of the joints (not connected to the inertial system) returns true for the function ismoving(joint).\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#Joint-types","page":"Joints and body-joint systems","title":"Joint types","text":"","category":"section"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"RevoluteJoint\nPrismaticJoint\nHelicalJoint\nSphericalJoint\nFreeJoint\nFreeJoint2d","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"","category":"page"},{"location":"manual/joints/","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"EditURL = \"<unknown>/literate/transforms.jl\"","category":"page"},{"location":"manual/transforms/#Plucker-vectors-and-coordinate-transforms","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"","category":"section"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"CurrentModule = RigidBodyTools","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"Here we discuss the use of Plücker vectors and their transforms for describing rigid-body motion and force. Plücker vectors succinctly describe both the angular (rotational) and linear (translational) part of motion, and the angular (moment) and linear (force) part of force. In three dimensions, a Plücker vector is 6-dimensional, e.g., Plücker velocity and force vectors are","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"v = beginbmatrix Omega_x  Omega_y  Omega_z  U_x  U_y  U_z endbmatrix qquad\nf = beginbmatrix M_x  M_y  M_z  F_x  F_y  F_z endbmatrix","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"In two dimensions, there is only one angular component and two linear components, e.g.,","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"v = beginbmatrix Omega_z  U_x  U_y endbmatrix qquad f = beginbmatrix M_z  F_x  F_y endbmatrix","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"We need to be able to transform these vectors from one coordinate system to another. This requires rotating their components and shifting their center from one origin to another. For example, a translational velocity based at system B will be different from the translational velocity at system A because of the rotational velocity, Omega times ^Br_A, where ^Br_A is the vector from the origin of A to the origin of B.","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"Similarly, the moment about B will be different from the moment about A due to the moment arm ^Br_A times F.","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"using RigidBodyTools\nusing LinearAlgebra\nusing Plots","category":"page"},{"location":"manual/transforms/#Plücker-vectors","page":"Plucker vectors and coordinate transforms","title":"Plücker vectors","text":"","category":"section"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"A Plücker vector is easily created by simply supplying a vector of its components","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"v = PluckerMotion([1.0,2.0,3.0])","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"This created a 2d motion vector, with angular velocity 1.0 and linear velocity (2.0,3.0). One can also supply the angular and linear parts separately, using keywords. If one of these keywords is omitted, it defaults to zero for that part. Note that we also need to write this as PluckerMotion{2} to specify the physical dimensionality. For a 3d motion vector, one would write PluckerMotion{3} here.","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"v2 = PluckerMotion{2}(angular=1.0,linear=[2.0,3.0])\nv2 == v","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"We can also pick off the angular and linear parts","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"angular_only(v)","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"and","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"linear_only(v)","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"Force vectors are similar","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"f = PluckerForce([-1.0,-3.5,2.25])","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"The vectors of the same type can be added and subtracted","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"v3 = v + v2","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"We can also take a scalar product of force and motion vectors","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"dot(f,v)","category":"page"},{"location":"manual/transforms/#Transforms","page":"Plucker vectors and coordinate transforms","title":"Transforms","text":"","category":"section"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"Transforms are constructed by describing the relationship between the two coordinate systems. Consider the example in the figure below.","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"(Image: CoordinateSystems.svg)","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"To develop the 2d transform from A to B, we supply the position r and the rotation angle theta. For example, if B is shifted by [1,1] and rotated by angle pi6 counterclockwise about A, then we construct the transform as","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"Xm = MotionTransform([1,1],π/6)","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"Note that it uses the angle of rotation, pi6, to create a rotation matrix operator.","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"A 2d force transform would be constructed by","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"Xf = ForceTransform([1,1],π/6)","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"For 3d transforms, we need to supply the rotation operator itself (as well as the 3d translation vector). Often, this rotation is done by rotating about a certain axis by a certain angle. We do this with the rotation_about_axis function. For example, to rotate by pi4 about an axis parallel to the vector 111, then we use","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"R = rotation_about_axis(π/4,[1,1,1])","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"and then to translate this rotated system by -1-2-3,","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"Xm = MotionTransform([-1,-2,-3],R)","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"and similarly for a force transform.","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"We can also compute the inverses of these transforms, to transform back from B to A","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"inv(Xm)","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"Transforms of the same type (motion or force) can be composed via multiplication to transform from, e.g., A to B to C.","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"Xm1 = MotionTransform([1.5,1.5],π/6)\nXm2 = MotionTransform([-1,1],π/3)\nXm2*Xm1","category":"page"},{"location":"manual/transforms/#Transforming-bodies","page":"Plucker vectors and coordinate transforms","title":"Transforming bodies","text":"","category":"section"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"We can use motion transforms, in particular, to place bodies. We simply apply the transform as a function, and it transforms the body's coordinates. For example, transform Xm1 above shifts the body to [1.5,1.5] and rotates it counterclockwise by π/6:","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"b = Ellipse(1.0,0.2,0.02)\nplot(b,xlims=(-3,3),ylims=(-3,3),fillcolor=:gray)\nplot!(Xm1(b),xlims=(-3,3),ylims=(-3,3))","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"In the example above, we did not affect the original body by applying the transform as a function. Rather, we created a copy of the body.","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"If, instead, you wish to transform the body in place, use update_body!","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"update_body!(b,Xm1)","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"One important note: a body stores a set of coordinates in its own intrinsic coordinate system, and when a transform is applied to the body, it always acts on these coordinates. This means that the transform's application on the body cannot be carried out as a composite of operations, e.g. T2(T1(b)) is not possible. Insteady, in the application on the body, the transform is always interpreted such that system A is the inertial coordinate system and B is the body system. Of course, the transform itself can always be constructed from composite transforms.","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"Sometimes we need information about the normals in the body system. For these, we can use normalmid with the flag axes=:body:","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"nx, ny = normalmid(b,axes=:body)","category":"page"},{"location":"manual/transforms/#Transforming-Plücker-vectors","page":"Plucker vectors and coordinate transforms","title":"Transforming Plücker vectors","text":"","category":"section"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"Transforms can be applied to Plücker vectors to transform their components between systems. Let's consider a 2d example in which the motion based at system A is purely a rotation with angular velocity Omega = 1, and we wish to transform this to system B, translated by 20 from A, but with axes aligned with B. We expect that the velocity based at B should have the same angular velocity, but also should have translational velocity equal to 02 due to the angular motion.","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"First we construct the motion vector at A","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"Ω = 1.0\nvA = PluckerMotion(Ω,[0,0])","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"Now construct the transform from A to B:","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"XA_to_B = MotionTransform([2,0],0)","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"Now apply the transform to get the velocity at B:","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"vB = XA_to_B*vA","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"which gives the expected result. Now let's transform back, using the inverse, and check that we get back to vA","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"inv(XA_to_B)*vB","category":"page"},{"location":"manual/transforms/#Transform-functions","page":"Plucker vectors and coordinate transforms","title":"Transform functions","text":"","category":"section"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"PluckerMotion\nPluckerForce\nangular_only\nlinear_only\nLinearAlgebra.dot(::PluckerForce,::PluckerMotion)\nMotionTransform\nForceTransform\nBase.inv(::AbstractTransformOperator)\nupdate_body!","category":"page"},{"location":"manual/transforms/#RigidBodyTools.PluckerMotion","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.PluckerMotion","text":"PluckerMotion(data::AbstractVector)\n\nCreates an instance of a Plucker motion vector,\n\nv = beginbmatrix Omega  U endbmatrix\n\nusing the vector in data. If data is of length 6, then it creates a 3d motion vector, and the first 3 entries are assumed to comprise the rotational component \\Omega and the last 3 entries the translational component U. If data is of length 3, then it creates a 2d motion vector, assuming that the first entry in data represents the rotational component and the second and third entries the x and y translational components.\n\n\n\n\n\n","category":"type"},{"location":"manual/transforms/#RigidBodyTools.PluckerForce","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.PluckerForce","text":"PluckerForce(data::AbstractVector)\n\nCreates an instance of a Plucker force vector,\n\nf = beginbmatrix M  F endbmatrix\n\nusing the vector in data. If data is of length 6, then it creates a 3d force vector, and the first 3 entries are assumed to comprise the moment component M and the last 3 entries the force component F. If data is of length 3, then it creates a 2d force vector, assuming that the first entry in data represents the moment component and the second and third entries the x and y force components.\n\n\n\n\n\n","category":"type"},{"location":"manual/transforms/#RigidBodyTools.angular_only","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.angular_only","text":"angular_only(v::AbstractPluckerVector)\n\nReturns a Plucker vector with only the angular part of the motion or force vector v available for subsequent operations. Note that no copy of the original data in v is made. Rather, this simply provides a lazy reference to the angular data in v.\n\n\n\n\n\n","category":"function"},{"location":"manual/transforms/#RigidBodyTools.linear_only","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.linear_only","text":"linear_only(v::AbstractPluckerVector)\n\nReturns a Plucker vector with only the linear part of the motion or force vector v available for subsequent operations. Note that no copy of the original data in v is made. Rather, this simply provides a lazy reference to the linear data in v.\n\n\n\n\n\n","category":"function"},{"location":"manual/transforms/#RigidBodyTools.MotionTransform","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.MotionTransform","text":"(T::MotionTransform)(b::Body) -> Body\n\nTransforms a body b using the given MotionTransform, creating a copy of this body with the new configuration. In using this transform T (which defines a transform from system A to system B), A is interpreted as an inertial coordinate system and B as the body system. Thus, the position vector in T is interpreted as the relative position of the body in inertial coordinates and the inverse of the rotation operator is applied to transform body-fixed coordinates to the inertial frame.\n\n\n\n\n\nMotionTransform(xA_to_B::SVector,RA_to_B::SMatrix) -> MotionTransform\n\nComputes the Plucker transform matrix for motion vectors, transforming from system A to system B. The input xA_to_B is the Euclidean vector from the origin of A to the origin of B, expressed in A coordinates, and RA_to_B is the rotation matrix transforming coordinates in system A to those in system B. The resulting matrix has the form\n\n^B T^(m)_A = beginbmatrix R  0  0  R endbmatrix beginbmatrix 1  0  -x^times  1 endbmatrix\n\nOne can also provide xA_to_B as a standard vector and RA_to_B as a standard 3 x 3 matrix.\n\nIf xA_to_B has length 3, then a three-dimensional transform (a 6 x 6 Plucker transform) is created. If xA_to_B has length 2, then a two-dimensional transform (3 x 3 Plucker transform) is returned.\n\n\n\n\n\nMotionTransform(xA_to_B,θ::Real) -> MotionTransform\n\nComputes the 3 x 3 2D Plucker transform matrix for motion vectors, transforming from system A to system B. The input xA_to_B is the 2-d Euclidean vector from the origin of A to the origin of B, expressed in A coordinates, and θ is the angle of system B relative to system A. xA_to_B can be in the form of a static vector, a vector, or a tuple.\n\n\n\n\n\nMotionTransform(T::RigidTransform) -> MotionTransform\n\nComputes the 3 x 3 2D Plucker transform matrix for motion vectors, transforming from system A to system B, from the rigid transform T.\n\n\n\n\n\n","category":"type"},{"location":"manual/transforms/#RigidBodyTools.ForceTransform","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.ForceTransform","text":"ForceTransform(xA_to_B::SVector,RA_to_B::SMatrix) -> ForceTransform\n\nComputes the 6 x 6 Plucker transform matrix for force vectors, transforming from system A to system B. The input xA_to_B is the Euclidean vector from the origin of A to the origin of B, expressed in A coordinates, and RA_to_B is the rotation matrix transforming coordinates in system A to those in system B. The resulting matrix has the form\n\n^B T^(f)_A = beginbmatrix R  0  0  R endbmatrix beginbmatrix 1  -x^times  0  1 endbmatrix\n\n\n\n\n\nForceTransform(xA_to_B,θ::Real) -> ForceTransform\n\nComputes the 3 x 3 2D Plucker transform matrix for force vectors, transforming from system A to system B. The input xA_to_B is the 2-d Euclidean vector from the origin of A to the origin of B, expressed in A coordinates, and θ is the angle of system B relative to system A. xA_to_B can be in the form of a static vector, a vector, or a tuple.\n\n\n\n\n\nForceTransform(T::RigidTransform) -> ForceTransform\n\nComputes the 3 x 3 2D Plucker transform matrix for force vectors, transforming from system A to system B, from the rigid transform T.\n\n\n\n\n\n","category":"type"},{"location":"manual/transforms/#Base.inv-Tuple{AbstractTransformOperator}","page":"Plucker vectors and coordinate transforms","title":"Base.inv","text":"inv(M)\n\nMatrix inverse. Computes matrix N such that M * N = I, where I is the identity matrix. Computed by solving the left-division N = M \\ I.\n\nExamples\n\njulia> M = [2 5; 1 3]\n2×2 Matrix{Int64}:\n 2  5\n 1  3\n\njulia> N = inv(M)\n2×2 Matrix{Float64}:\n  3.0  -5.0\n -1.0   2.0\n\njulia> M*N == N*M == Matrix(I, 2, 2)\ntrue\n\n\n\n\n\ninv(X::AbstractTransformOperator) -> AbstractTransformOperator\n\nReturn the inverse of the motion or force transform X.\n\n\n\n\n\n","category":"method"},{"location":"manual/transforms/#RigidBodyTools.update_body!","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.update_body!","text":"update_body!(b::Body,t::MotionTransform)\n\nTransforms a body (in-place) using the given MotionTransform. In using this transform T (which defines a transform from system A to system B), A is interpreted as an inertial coordinate system and B as the body system. Thus, the position vector in T is interpreted as the relative position of the body in inertial coordinates and the inverse of the rotation operator is applied to transform body-fixed coordinates to the inertial frame.\n\n\n\n\n\nupdate_body!(bl::BodyList,tl::MotionTransformList) -> BodyList\n\nCarry out in-place transformations of each body in bl with the corresponding transformation in tl.\n\n\n\n\n\nupdate_body!(bl::BodyList,x::AbstractVector,m::RigidBodyMotion)\n\nUpdate body b with the rigid-body motion m and state vector x.\n\n\n\n\n\n","category":"function"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"","category":"page"},{"location":"manual/transforms/","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"EditURL = \"<unknown>/literate/bodylists.jl\"","category":"page"},{"location":"manual/bodylists/#Lists-of-bodies-and-their-transforms","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"","category":"section"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"CurrentModule = RigidBodyTools","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"We might want to have several distinct bodies. Here, we discuss how to combine bodies into lists, and similarly, their transforms.","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"using RigidBodyTools\nusing Plots","category":"page"},{"location":"manual/bodylists/#Body-list","page":"Lists of bodies and their transforms","title":"Body list","text":"","category":"section"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"Suppose we have two bodies and we wish to combine them into a single list. The advantage of doing so is that many of the operations we have presented previously also extend to lists. We use BodyList to combine them.","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"b1 = Circle(1.0,0.02)\nb2 = Rectangle(1.0,2.0,0.02)\nbl = BodyList([b1,b2])","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"Another way to do this is to push each one onto the list:","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"bl = BodyList()\npush!(bl,b1)\npush!(bl,b2)","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"We can transform the list by creating a list of transforms with a MotionTransformList","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"X1 = MotionTransform([2.0,3.0],0.0)\nX2 = MotionTransform([-2.0,-0.5],π/4)\ntl = MotionTransformList([X1,X2])","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"The transform list can be applied to the whole body list simply with","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"tl(bl)","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"which creates a copy of the body list and transforms that, or","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"update_body!(bl,tl)","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"which updates each body in bl in place.","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"Let's see our effect","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"plot(bl)","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"It is important to note that the list points to the original bodies, so that any change made to the list is reflected in the original bodies, e.g.","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"plot(b2)","category":"page"},{"location":"manual/bodylists/#Utilities-on-lists","page":"Lists of bodies and their transforms","title":"Utilities on lists","text":"","category":"section"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"There are some specific utilities that are helpful for lists. For example, to collect all of the x, y points (the segment midpoints) in the list into two vectors, use","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"x, y = collect(bl)","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"In a vector comprising data on these concatenated surface points, we can use view to look at just one body's part and change it:","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"f = zero(x)\nf1 = view(f,bl,1)\nf1 .= 1.0;\nplot(f)","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"Also, we can sum up the values for one of the bodies:","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"sum(f,bl,2)","category":"page"},{"location":"manual/bodylists/#Body-and-transform-list-functions","page":"Lists of bodies and their transforms","title":"Body and transform list functions","text":"","category":"section"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"BodyList\ngetrange\nBase.collect(::BodyList)\nBase.sum(::AbstractVector,::BodyList,::Int)\nBase.view(::AbstractVector,::BodyList,::Int)\nMotionTransformList","category":"page"},{"location":"manual/bodylists/#RigidBodyTools.BodyList","page":"Lists of bodies and their transforms","title":"RigidBodyTools.BodyList","text":"BodyList([b1,b2,...])\n\nCreate a list of bodies\n\n\n\n\n\n","category":"type"},{"location":"manual/bodylists/#RigidBodyTools.getrange","page":"Lists of bodies and their transforms","title":"RigidBodyTools.getrange","text":"getrange(bl::BodyList,bid::Int) -> Range\n\nReturn the subrange of indices in the global set of surface point data corresponding to body bid in a BodyList bl.\n\n\n\n\n\ngetrange(ls::RigidBodyMotion,dimfcn::Function,jid::Int) -> Range\n\nReturn the subrange of indices in the global state vector for the state corresponding to joint jid in linked system ls.\n\n\n\n\n\n","category":"function"},{"location":"manual/bodylists/#Base.collect-Tuple{BodyList}","page":"Lists of bodies and their transforms","title":"Base.collect","text":"collect(bl::bodylist[,endpoints=false][,ref=false]) -> Vector{Float64}, Vector{Float64}\n\nCollect the inertial-space coordinates of all of the Lagrange points comprising the bodies in body list bl and return each assembled set of coordinates as a vector. By default, endpoints=false and ref=false, which means this collects the midpoints of segments in the inertial coordinates. If endpoints=true it collects segment endpoints instead. If ref=true it collects the coordinates in the body coordinate system.\n\n\n\n\n\n","category":"method"},{"location":"manual/bodylists/#Base.sum-Tuple{AbstractVector, BodyList, Int64}","page":"Lists of bodies and their transforms","title":"Base.sum","text":"sum(f::AbstractVector,bl::BodyList,i::Int) -> Real\n\nCompute a sum of the elements of vector f corresponding to body i in body list bl.\n\n\n\n\n\n","category":"method"},{"location":"manual/bodylists/#Base.view-Tuple{AbstractVector, BodyList, Int64}","page":"Lists of bodies and their transforms","title":"Base.view","text":"view(f::AbstractVector,bl::BodyList,bid::Int) -> SubArray\n\nProvide a view of the range of values in vector f corresponding to the Lagrange points of the body with index bid in a BodyList bl.\n\n\n\n\n\n","category":"method"},{"location":"manual/bodylists/#RigidBodyTools.MotionTransformList","page":"Lists of bodies and their transforms","title":"RigidBodyTools.MotionTransformList","text":"MotionTransformList([t1,t2,...])\n\nCreate a list of motion transforms\n\n\n\n\n\n","category":"type"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"EditURL = \"<unknown>/literate/deformation.jl\"","category":"page"},{"location":"manual/deformation/#Deforming-bodies","page":"Deforming bodies","title":"Deforming bodies","text":"","category":"section"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"CurrentModule = RigidBodyTools","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"Thus far we have only shown rigid body motion. However, we can also prescribe surface deformation as an additional component of a body's motion.","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"using RigidBodyTools\nusing Plots","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"Before we get started, let's define the same macro that we used earlier in order to visualize our system's motion","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"macro animate_motion(b,m,dt,tmax,xlim,ylim)\n    return esc(quote\n            bc = deepcopy($b)\n            t0, x0 = 0.0, init_motion_state(bc,$m)\n            dxdt = zero(x0)\n            x = copy(x0)\n\n            @gif for t in t0:$dt:t0+$tmax\n                motion_rhs!(dxdt,x,($m,bc),t)\n                global x += dxdt*$dt\n                update_body!(bc,x,$m)\n                plot(bc,xlims=$xlim,ylims=$ylim)\n            end every 5\n        end)\nend","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"For deforming bodies, we specify the velocity of the surface directly. This deformation velocity is expressed in the coordinate system attached to the body, rather than the inertial coordinate system. This enables the motion to be easily superposed with the rigid-body motion described earlier.","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"It is also important to note that the motion is applied to the endpoints of the surface segments. The midpoints are then constructed from the updated endpoints.","category":"page"},{"location":"manual/deformation/#Example:-Basic-deformation","page":"Deforming bodies","title":"Example: Basic deformation","text":"","category":"section"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"Let's see an example. We will create an oscillatory deformation of a circle. We create the motion by creating functions for each component of velocity.","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"Ω = 2π\nufcn(x,y,t) = 0.25*x*y*Ω*cos(Ω*t)\nvfcn(x,y,t) = 0.25*(x^2-y^2)*Ω*cos(Ω*t)\ndef = DeformationMotion(ufcn,vfcn)","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"We will create a simple fixed revolute joint that anchors the body's center to the inertial system. (Note that we don't need to create a body list here, since we are only working with one body and one joint.)","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"Xp_to_jp = MotionTransform(0.0,0.0,0.0)\nXc_to_jc = MotionTransform(0.0,0.0,0.0)\ndofs = [ConstantVelocityDOF(0.0)]\njoint = Joint(RevoluteJoint,0,Xp_to_jp,1,Xc_to_jc,dofs)\n\nbody = Circle(1.0,0.02)","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"To construct the system, we supply the joint and body, as before, as well as the deformation.","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"ls = RigidBodyMotion(joint,body,def)","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"Let's animate this motion","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"@animate_motion body ls 0.01 4 (-2,2) (-2,2)","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"The body remains fixed, but the surface deforms!","category":"page"},{"location":"manual/deformation/#Example:-Expanding-motion","page":"Deforming bodies","title":"Example: Expanding motion","text":"","category":"section"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"Now a circle undergoing an expansion. For this, we set constant velocity components equal to constants, the coordinates of the surface segment endpoints","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"body = Circle(1.0,0.02)\n\nu = copy(body.x̃end)\nv = copy(body.ỹend)\ndef = ConstantDeformationMotion(u,v)\n\nls = RigidBodyMotion(joint,body,def)\n@animate_motion body ls 0.01 2 (-5,5) (-5,5)","category":"page"},{"location":"manual/deformation/#Example:-Combining-rigid-motion-and-deforming-motion.","page":"Deforming bodies","title":"Example: Combining rigid motion and deforming motion.","text":"","category":"section"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"Now, let's combine an oscillatory rigid-body rotation with oscillatory deformation, this time applied to a square.","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"Xp_to_jp = MotionTransform(0.0,0.0,0.0)\nXc_to_jc = MotionTransform(0.0,0.0,0.0)\nΩ = 1.0\ndofs = [OscillatoryDOF(π/4,Ω,0.0,0.0)]\njoint = Joint(RevoluteJoint,0,Xp_to_jp,1,Xc_to_jc,dofs)\n\nbody = Square(1.0,0.02)\n\nufcn(x,y,t) = 0.25*(x^2+y^2)*y*Ω*cos(Ω*t)\nvfcn(x,y,t) = -0.25*(x^2+y^2)*x*Ω*cos(Ω*t)\ndef = DeformationMotion(ufcn,vfcn)\n\nls = RigidBodyMotion(joint,body,def)\n\n@animate_motion body ls π/100 4π (-2,2) (-2,2)","category":"page"},{"location":"manual/deformation/#Example:-Defining-new-deformations","page":"Deforming bodies","title":"Example: Defining new deformations","text":"","category":"section"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"We can also define new types of deformation that are more specialized. We need only define a subtype of AbstractDeformationMotion and extend the function deformation_velocity to work with it. The signature of this function is deformation_velocity(body,deformation,time).","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"For example, let's define a motion on a rectangular shape that will deform only the top side in the normal direction, but leave the rest of the surface stationary. We will use the side field of the Polygon shape type to access the top, and set its vertical velocity.","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"struct TopMotion{UT} <: AbstractDeformationMotion\n    vtop :: UT\nend\n\nfunction RigidBodyTools.deformation_velocity(body::Polygon,def::TopMotion,t::Real)\n\n    u, v = zero(body.x̃end), zero(body.ỹend)\n    top = body.side[3]\n    v[top] .= def.vtop.(body.x̃end[top],body.ỹend[top],t)\n    return vcat(u,v)\nend","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"Now apply it","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"Xp_to_jp = MotionTransform(0.0,0.0,0.0)\nXc_to_jc = MotionTransform(0.0,0.0,0.0)\ndofs = [ConstantVelocityDOF(0.0)]\njoint = Joint(RevoluteJoint,0,Xp_to_jp,1,Xc_to_jc,dofs)\n\nbody = Rectangle(1.0,2.0,0.02)\nvfcn(x,y,t) = 0.2*(1-x^2)*cos(t)\ndef = TopMotion(vfcn)\n\nls = RigidBodyMotion(joint,body,def)","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"Let's try it out","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"@animate_motion body ls π/100 4π (-1.5,1.5) (-2.5,2.5)","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"As desired, the top surface deforms vertically, but the rest of the surface is stationary.","category":"page"},{"location":"manual/deformation/#Deformation-functions","page":"Deforming bodies","title":"Deformation functions","text":"","category":"section"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"DeformationMotion\nConstantDeformationMotion","category":"page"},{"location":"manual/deformation/#RigidBodyTools.DeformationMotion","page":"Deforming bodies","title":"RigidBodyTools.DeformationMotion","text":"DeformationMotion(u::Function,v::Function)\n\nCreate an instance of directly-specified velocity whose components are specified with functions. These functions u and v must each be of the form f(x̃,ỹ,t), where x̃ and ỹ are coordinates of a point in the body coordinate system and t is time, and they must return the corresponding velocity component in the body coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"manual/deformation/#RigidBodyTools.ConstantDeformationMotion","page":"Deforming bodies","title":"RigidBodyTools.ConstantDeformationMotion","text":"ConstantDeformationMotion(u::Vector{Float64},v::Vector{Float64})\n\nCreate an instance of basic directly-specified (constant) velocity, to be associated with a body whose length is the same as u and v.\n\n\n\n\n\n","category":"type"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"","category":"page"},{"location":"manual/deformation/","page":"Deforming bodies","title":"Deforming bodies","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"EditURL = \"<unknown>/literate/shapes.jl\"","category":"page"},{"location":"manual/shapes/#Creating-bodies","page":"Creating bodies","title":"Creating bodies","text":"","category":"section"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"CurrentModule = RigidBodyTools","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"The most basic functions of this package create an object of type Body. There are a variety of such functions, a few of which we will demonstrate here. Generally speaking, we are interesting in creating the object and placing it in a certain position and orientation. We do this in two steps: we create the basic shape, centered at the origin with a default orientation, and then we transform the shape to a desired location and orientation. We will discuss the shapes in this notebook, and the transforms in the following notebook.","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"It is useful to stress that each body stores two types of points internally: the endpoints of the segments that comprise the body surface, and the midpoints of these segments. The midpoints are intended for use in downstream calculations, e.g. as forcing points in the calculations on immersed layers. The midpoints are simply the geometric averages of the endpoints, so endpoints are the ones that are transformed first, and midpoints are updated next.","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"using RigidBodyTools\nusing Plots","category":"page"},{"location":"manual/shapes/#Creating-a-shape","page":"Creating bodies","title":"Creating a shape","text":"","category":"section"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"Let's first create a shape. For any shape, we have to make a choice of the geometric dimensions (e.g, radius of the circle, side lengths of a rectangle), as well as the points that we use to discretely represent the surface. For this latter choice, there are two constructor types: we can specify the number of points (as an integer), or we can specify the nominal spacing between points (as a floating-point number).","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"The second approach is usually preferable when we use these tools for constructing immersed bodies. It is important to stress that the algorithms for placing points attempt to make the spacing as uniform as possible.","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"Let's create the most basic shape, a circle of radius 1. We will discretize it with 100 points first:","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"b = Circle(1.0,100)","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"Now we will create the same body with a spacing of 0.02","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"b = Circle(1.0,0.02)","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"This choice led to 312 points along the circumference. Quick math will tell you that the point spacing is probably not exactly 0.02. In fact, you can find out the actual spacing with dlengthmid. This function calculates the spacing associated with each point. (It does so by first calculating the spacing between midpoints between each point and its two adjacent points.)","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"dlengthmid(b)","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"It is just a bit larger than 0.02.","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"A few other useful functions on the shape. To simply know the number of points,","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"length(b)","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"To find the outward normal vectors (based on the perpendicular to the line joining the adjacent midpoints):","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"nx, ny = normalmid(b)","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"We can also plot the shape","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"plot(b)","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"Sometimes we don't want to fill in the shape (and maybe change the line color). In that case, we can use","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"plot(b,fill=:false,linecolor=:black)","category":"page"},{"location":"manual/shapes/#Other-shapes","page":"Creating bodies","title":"Other shapes","text":"","category":"section"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"Let's see some other shapes in action, like a square and an ellipse","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"b1, b2 = Square(1.0,0.02), Ellipse(0.6,0.1,0.02)\nplot(plot(b1), plot(b2))","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"A NACA 4412 airfoil, with chord length 1, and 0.02 spacing between points.","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"b = NACA4(0.04,0.4,0.12,0.02)\nplot(b)","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"A flat plate with no thickness","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"b = Plate(1.0,0.02)\nplot(b)","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"and a flat plate with a 5 percent thickness (and rounded ends)","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"b = ThickPlate(1.0,0.05,0.01)\nplot(b)","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"There are also some generic tools for creating shapes. A BasicBody simply consists of points that describe the vertices. The interface for this is very simple.","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"x = [1.0, 1.2, 0.7, 0.6, 0.2, -0.1, 0.1, 0.4]\ny = [0.1, 0.5, 0.8, 1.2, 0.8, 0.6, 0.2, 0.3]\nb = BasicBody(x,y)","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"plot(b)\nscatter!(b,markersize=3,markercolor=:black)","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"However, this function does not insert any points along the sides between vertices. We have to do the work of specifying these points in the original call. For this reason, there are a few functions that are more directly useful. For example, we can create a polygon from these vertices, with a specified spacing between points distributed along the polygon sides","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"b = Polygon(x,y,0.02)","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"plot(b)\nscatter!(b,markersize=3,markercolor=:black)","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"Alternatively, we can interpret those original points as control points for splines, with a spacing between points along the splines provided:","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"b = SplinedBody(x,y,0.02)","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"plot(b)\nscatter!(b,markersize=3,markercolor=:black)","category":"page"},{"location":"manual/shapes/#Body-functions","page":"Creating bodies","title":"Body functions","text":"","category":"section"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"BasicBody\nPolygon\nCircle\nEllipse\nNACA4\nPlate\nRectangle\nSplinedBody\nSquare","category":"page"},{"location":"manual/shapes/#RigidBodyTools.BasicBody","page":"Creating bodies","title":"RigidBodyTools.BasicBody","text":"BasicBody(x,y[,closuretype=ClosedBody]) <: Body\n\nConstruct a body by simply passing in the x and y coordinate vectors. The last point will be automatically connected to the first point. The coordinate vectors are assumed to be expressed in the body-fixed coordinate system. The optional closuretype specifies whether the body is closed (ClosedBody) or open (OpenBody). If closed, then the first and last points are assumed joined in operations that require neighbor points.\n\n\n\n\n\n","category":"type"},{"location":"manual/shapes/#RigidBodyTools.Polygon","page":"Creating bodies","title":"RigidBodyTools.Polygon","text":"Polygon(x::Vector,y::Vector,n[,closuretype=ClosedBody])\n\nCreate a polygon shape with vertices x and y, with approximately n points distributed along the perimeter.\n\n\n\n\n\n","category":"type"},{"location":"manual/shapes/#RigidBodyTools.Circle","page":"Creating bodies","title":"RigidBodyTools.Circle","text":"Circle(a,n) <: Body\n\nConstruct a circular body with radius a and with n points distributed on the body perimeter.\n\n\n\n\n\nCircle(a,targetsize::Float64) <: Body\n\nConstruct a circular body with radius a with spacing between points set approximately to targetsize.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.Ellipse","page":"Creating bodies","title":"RigidBodyTools.Ellipse","text":"Ellipse(a,b,n[,endpointson=false],[shifted=false]) <: Body\n\nConstruct an elliptical body with semi-major axis a and semi-minor axis b, with n points distributed on the body perimeter. Can also call this with Ellipse(a,b,ds) where ds is the desired spacing between points. If endpointson=true, then the endpoints will be placed on the surface and the midpoints will lie inside the nominal ellipse. By default, the midpoints lie on the ellipse. If shifted=true, then the first endpoint lies on an axis of symmetry. By default the first midpoint lies on the axis symmetry.\n\n\n\n\n\n","category":"type"},{"location":"manual/shapes/#RigidBodyTools.NACA4","page":"Creating bodies","title":"RigidBodyTools.NACA4","text":"NACA4(cam,pos,thick,np,[len=1.0]) <: Body{N}\n\nGenerates points in the shape of a NACA 4-digit airfoil of chord length 1. The relative camber is specified by cam, the position of maximum camber (as fraction of chord) by pos, and the relative thickness by thick. The parameter np specifies the number of points on the upper or lower surface. The optional parameter len specifies the chord length, which defaults to 1.0.\n\nExample\n\njulia> b = NACA4(0.0,0.0,0.12);\n\n\n\n\n\n","category":"type"},{"location":"manual/shapes/#RigidBodyTools.Plate","page":"Creating bodies","title":"RigidBodyTools.Plate","text":"Plate(a,n) <: Body\n\nConstruct a flat plate of zero thickness with length a, divided into n equal segments.\n\n\n\n\n\nPlate(a,ds) <: Body\n\nConstruct a flat plate of zero thickness with length a, with approximate spacing ds between points.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.Rectangle","page":"Creating bodies","title":"RigidBodyTools.Rectangle","text":"Rectangle(a,b,n) <: Body\n\nConstruct a rectangular body with x̃ side half-length a and ỹ side half-length b, with approximately n points distributed along the perimeter. The centroid of the rectangle is placed at the origin (so that the lower left corner is at (-a,-b)).\n\nPoints are not placed at the corners, but rather, are shifted by half a segment. This ensures that all normals are perpendicular to the sides.\n\n\n\n\n\nRectangle(a,b,ds) <: Body\n\nConstruct a rectangular body with x̃ side half-length a and ỹ side half-length b, with approximate spacing ds between points.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.SplinedBody","page":"Creating bodies","title":"RigidBodyTools.SplinedBody","text":"SplinedBody(X,Δx[,closuretype=ClosedBody]) -> BasicBody\n\nUsing control points in X (assumed to be N x 2, where N is the number of points), create a set of points that are uniformly spaced (with spacing Δx) on a curve that passes through the control points. A cubic parametric spline algorithm is used. If the optional parameter closuretype is set to OpenBody, then the end points are not joined together.\n\n\n\n\n\nSplinedBody(x,y,Δx[,closuretype=ClosedBody]) -> BasicBody\n\nUsing control points in x and y, create a set of points that are uniformly spaced (with spacing Δx) on a curve that passes through the control points. A cubic parametric spline algorithm is used. If the optional parameter closuretype is set to OpenBody, then the end points are not joined together.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.Square","page":"Creating bodies","title":"RigidBodyTools.Square","text":"Square(a,n) <: Body\n\nConstruct a square body with side half-length a and with approximately n points distributed along the perimeter.\n\n\n\n\n\nSquare(a,ds) <: Body\n\nConstruct a square body with side half-length a, with approximate spacing ds between points.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#Shape-utilities","page":"Creating bodies","title":"Shape utilities","text":"","category":"section"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"centraldiff\nBase.diff(::Body)\nBase.diff(::BodyList)\ndlength\ndlengthmid\nBase.length(::Body)\nmidpoints(::Body)\nmidpoints(::BodyList)\nnormal\nnormalmid\narccoord\narccoordmid\narclength(::Body)\narclength(::BodyList)","category":"page"},{"location":"manual/shapes/#RigidBodyTools.centraldiff","page":"Creating bodies","title":"RigidBodyTools.centraldiff","text":"centraldiff(body::Body[;axes=:inertial]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the circular central differences of coordinates on body body (or on each body in list body). If axes=:body, uses the reference coordinates in body-fixed space.\n\n\n\n\n\ncentraldiff(bl::BodyList[;axes=:inertial]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the centraldiff on each constituent body in bl.  If axes=:body, uses the reference coordinates in body-fixed space.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#Base.diff-Tuple{Body}","page":"Creating bodies","title":"Base.diff","text":"diff(body::Body[;axes=:inertial]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the x and y differences of the faces on the perimeter of body body, whose ends are at the current x and y coordinates (in inertial space) of the body (if axes=:inertial), or at the reference x̃ and ỹ coordinates (body-fixed space) if axes=:body. Face 1 corresponds to the face between points 1 and 2, for example.\n\nIf body is a BodyList, then it computes the differences separately on each constituent body.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#Base.diff-Tuple{BodyList}","page":"Creating bodies","title":"Base.diff","text":"diff(bl::BodyList[;axes=:inertial]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the diff on each constituent body in bl.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#RigidBodyTools.dlength","page":"Creating bodies","title":"RigidBodyTools.dlength","text":"dlength(body::Body/BodyList[;axes=:inertial]) -> Vector{Float64}\n\nCompute the lengths of the faces on the perimeter of body body, whose ends are at the current xend and yend coordinates (in inertial space) of the body. Face 1 corresponds to the face between endpoints 1 and 2, for example. If axes=:body, uses the reference coordinates in body-fixed space.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.dlengthmid","page":"Creating bodies","title":"RigidBodyTools.dlengthmid","text":"dlengthmid(body::Body/BodyList[;axes=:inertial]) -> Vector{Float64}\n\nSame as dlength.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#Base.length-Tuple{Body}","page":"Creating bodies","title":"Base.length","text":"length(body::Body)\n\nReturn the number of points on the body perimeter\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#RigidBodyTools.midpoints-Tuple{Body}","page":"Creating bodies","title":"RigidBodyTools.midpoints","text":"midpoints(body::Body[;axes=:inertial]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the x and y midpoints of the faces on the perimeter of body body, whose ends are at the current x and y coordinates (in inertial space) of the body (if axes=:inertial), or at the reference x̃ and ỹ coordinates (body-fixed space) if axes=:body. Face 1 corresponds to the face between points 1 and 2, for example.\n\nIf body is a BodyList, then it computes the differences separately on each constituent body.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#RigidBodyTools.midpoints-Tuple{BodyList}","page":"Creating bodies","title":"RigidBodyTools.midpoints","text":"midpoints(bl::BodyList[;axes=:inertial]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the midpoints on each constituent body in bl.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#RigidBodyTools.normal","page":"Creating bodies","title":"RigidBodyTools.normal","text":"normal(body::Body/BodyList[;axes=:inertial]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the current normals in inertial components (if axes=:inertial) or body-   fixed components (if axes=:body) of the faces on the perimeter of body body, whose ends are at the current xend and yend coordinates (in inertial space) of the body. Face 1 corresponds to the face between points 1 and 2, for example. For an OpenBody, this provides a vector that is one element shorter than the number of points.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.normalmid","page":"Creating bodies","title":"RigidBodyTools.normalmid","text":"normalmid(body::Body/BodyList[;axes=:inertial]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the current normals in inertial components (if axes=:inertial) or body-   fixed components (if axes=:body) of the faces formed between endpoints on the perimeter of body body (or each body in list body).\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.arccoord","page":"Creating bodies","title":"RigidBodyTools.arccoord","text":"arccoord(body::Body/BodyList[;axes=:inertial]) -> Vector{Float64}\n\nReturns a vector containing the arclength coordinate along the surface of body, evaluated at the second endpoint of each face. So, e.g., the first coordinate would be the length of face 1, the second the length of face 2, and the last would be total length of all of the faces. Use inertial components (if axes=:inertial) or body-fixed components (if axes=:body). If this is a body list, restart the origin of the coordinates on each body in the list.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.arccoordmid","page":"Creating bodies","title":"RigidBodyTools.arccoordmid","text":"arccoordmid(body::Body/BodyList[;axes=:inertial]) -> Vector{Float64}\n\nReturns a vector containing the arclength coordinate along the surface of body, evaluated at the midpoints between the ends of faces. So, e.g., the first coordinate would be half of the length of face 1, the second would be half of face 2 plus all of face 1, etc. Use inertial components (if axes=:inertial) or body-   fixed components (if axes=:body). If this is a body list, restart   the origin of the coordinates on each body in the list.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.arclength-Tuple{Body}","page":"Creating bodies","title":"RigidBodyTools.arclength","text":"arclength(body::Body[;axes=:inertial])\n\nCompute the total arclength of body, from the sum of the lengths of the faces. If axes=:body, use the body-fixed coordinates.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#RigidBodyTools.arclength-Tuple{BodyList}","page":"Creating bodies","title":"RigidBodyTools.arclength","text":"arclength(bl::BodyList[;axes=:inertial]) -> Vector{Float64}\n\nCompute the total arclength of each body in bl and assemble the results into a vector. If axes=:body, use the body-fixed coordinates.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"","category":"page"},{"location":"manual/shapes/","page":"Creating bodies","title":"Creating bodies","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/utilities/#Surface-functions-and-other-utilities","page":"Surface functions and other utilities","title":"Surface functions and other utilities","text":"","category":"section"},{"location":"manual/utilities/","page":"Surface functions and other utilities","title":"Surface functions and other utilities","text":"DocTestSetup = quote\n  using RigidBodyTools\nend","category":"page"},{"location":"manual/utilities/","page":"Surface functions and other utilities","title":"Surface functions and other utilities","text":"centraldiff\nBase.diff(::Body)\nBase.diff(::BodyList)\ndlength\ndlengthmid\nBase.length(::Body)\nmidpoints(::Body)\nmidpoints(::BodyList)\nnormal\nnormalmid","category":"page"},{"location":"#RigidBodyTools.jl","page":"Home","title":"RigidBodyTools.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools for creating, moving, and discretizing rigid bodies","category":"page"},{"location":"","page":"Home","title":"Home","text":"The purpose of this package is to provide tools for rigid bodies with point-discretized surfaces. It includes methods for","category":"page"},{"location":"","page":"Home","title":"Home","text":"a library of surface shape definitions and associated point discretizations\ncalculation of geometric properties\nrigid-body motion and transformation of surface points\ncollections of multiple rigid bodies","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package works on Julia 1.0 and above and is registered in the general Julia registry. To install from the REPL, type e.g.,","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add RigidBodyTools","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, in any version, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using RigidBodyTools","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plots in this documentation are generated using Plots.jl. You might want to install that, too, to follow the examples.","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"EditURL = \"<unknown>/literate/exogenous.jl\"","category":"page"},{"location":"manual/exogenous/#Exogenous-degrees-of-freedom","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"","category":"section"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"CurrentModule = RigidBodyTools","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"As we mentioned in previous pages, some degrees of freedom can be designated as exogenous, meaning that their behavior is determined by some external process that we do not model explicitly. In practice, that means that the acceleration of such a degree of freedom must by explicitly provided at every time step while the state vector is being advanced.","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"using RigidBodyTools\nusing Plots","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"As usual, we will demonstrate this via an example. In the example, a single flat plate will be commanded to pitch upward by 45 degrees about its leading edge. It will move steadily in the +x direction. However, its y acceleration will vary randomly via some exogenous process.","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"Xp_to_jp = MotionTransform(0.0,0.0,0.0)\nXc_to_jc = MotionTransform(0.5,0.0,0.0)\ndofs = [SmoothRampDOF(0.4,π/4,0.5),ConstantVelocityDOF(1.0),ExogenousDOF()]\njoint = Joint(FreeJoint2d,0,Xp_to_jp,1,Xc_to_jc,dofs)\n\nbody = ThickPlate(1.0,0.05,0.02)","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"We need to provide a means of passing along the time-varying information about the exogenous acclerations to the time integrator. There are two ways we can do this.","category":"page"},{"location":"manual/exogenous/#Method-1:-A-function-for-exogenous-acclerations.","page":"Exogenous degrees of freedom","title":"Method 1: A function for exogenous acclerations.","text":"","category":"section"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"We can provide a function that will specify the exogenous y acceleration. Here, we will create a function that sets it to a random value chosen from a normal distribution. Note that the function must be mutating and have a signature (a,x,p,t), where a is the exogenous acceleration vector. The arguments x and p are a state and a parameter, which can be flexibly defined. Here, the state is the rigid-body system state and the parameter is the RigidBodyMotion structure. The last argument t is time.","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"In this example, we don't need any of those arguments.","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"function my_exogenous_function!(a,x,ls,t)\n    a .= randn(length(a))\nend","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"We pass that along via the exogenous keyword argument.","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"ls = RigidBodyMotion(joint,body;exogenous=my_exogenous_function!)","category":"page"},{"location":"manual/exogenous/#Method-2:-Setting-the-exogenous-accelerations-explicitly-in-the-loop","page":"Exogenous degrees of freedom","title":"Method 2: Setting the exogenous accelerations explicitly in the loop","text":"","category":"section"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"Another approach we can take is to set the exogenous acceleration(s) explicitly in the loop, using the update_exogenous! function. This function saves the vector of accelerations in a buffer in the RigidBodyMotion structure so that it is available to the time integrator. We will demonstrate that approach here.","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"ls = RigidBodyMotion(joint,body)","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"Let's initialize the state vector and its rate of change","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"bc = deepcopy(body)\ndt, tmax = 0.01, 3.0\nt0, x0 = 0.0, init_motion_state(bc,ls)\ndxdt = zero(x0)\nx = copy(x0)","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"Note that the state vector has four elements. The first two are associated with the prescribed motions for rotation and x translation. The third is the y position, the exogenous degree of freedom. And the fourth is the y velocity.","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"Why the y velocity? Because the exogenous behavior is specified via its acceleration. Let's advance the system and animate it. We include a horizontal line along the hinge axis to show the effect of the exogenous motion.","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"xhist = []\na_edof = zero_exogenous(ls)\n@gif for t in t0:dt:t0+tmax\n\n  a_edof .= randn(length(a_edof))\n\n  update_exogenous!(ls,a_edof)\n  motion_rhs!(dxdt,x,(ls,bc),t)\n  global x += dxdt*dt\n  update_body!(bc,x,ls)\n\n  push!(xhist,copy(x))\n  plot(bc,xlims=(-1,5),ylims=(-1.5,1.5))\n  hline!([0.0])\nend every 5","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"Let's plot the exogenous state and its velocity","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"plot(t0:dt:t0+tmax,map(x -> exogenous_position_vector(x,ls,1)[1],xhist),label=\"y position\",xlabel=\"t\")\nplot!(t0:dt:t0+tmax,map(x -> exogenous_velocity_vector(x,ls,1)[1],xhist),label=\"y velocity\")","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"The variation in velocity is quite noisy (and constitutes a random walk). In contrast, the change in position is relatively smooth, since it represents an integral of this velocity.","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"","category":"page"},{"location":"manual/exogenous/","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"EditURL = \"<unknown>/literate/dofmotions.jl\"","category":"page"},{"location":"manual/dofmotions/#Behaviors-of-degrees-of-freedom","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"","category":"section"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"CurrentModule = RigidBodyTools","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"To define the motion of a joint requires that we define the behavior of each of the joint's degrees of freedom. There are three different types of behavior of a degree of freedom: (1) Its motion is prescribed with a given function of time, in which case we say that the     degree of freedom is constrained (2) Its motion is specified directly, but determined by a process that lies outside     of the body system, in which case we say the degree of freedom is exogenous. (3) Its motion is determined indirectly by some sort of force model for its behavior,     such as a spring or damper, in which case we say the degree of freedom is unconstrained.","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"Here, we will discuss how to set a degree of freedom with one of these behaviors, and how to set the prescribed motion, if desired.","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"using RigidBodyTools\nusing Plots","category":"page"},{"location":"manual/dofmotions/#Constrained-behavior-(i.e.,-prescribed-motion)","page":"Behaviors of degrees of freedom","title":"Constrained behavior (i.e., prescribed motion)","text":"","category":"section"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"When a degree of freedom is constrained, then its behavior over time is set by some time-varying function. There are a number of different types of predefined time-varying behaviors.","category":"page"},{"location":"manual/dofmotions/#Constant-velocity","page":"Behaviors of degrees of freedom","title":"Constant velocity","text":"","category":"section"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"To specify constant velocity with some velocity, e.g. U=1, set","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"U = 1.0\nk = ConstantVelocityDOF(U)","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"For any prescribed motion, we can evaluate it at any specified time. It returns data of type DOFKinematicData.","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"t = 1.0\nkt = k(t)","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"The kinematic data can be parsed with dof_position, dof_velocity, and dof_acceleration:","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"dof_position(kt)","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"dof_velocity(kt)","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"dof_acceleration(kt)","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"Let's plot the position over time","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"t = range(0,3,length=301)\nplot(t,dof_position.(k.(t)),xlims=(0,Inf),ylims=(0,Inf))","category":"page"},{"location":"manual/dofmotions/#Oscillatory-motion","page":"Behaviors of degrees of freedom","title":"Oscillatory motion","text":"","category":"section"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"We can set the position to be a sinusoidal function. For this, we set the amplitude, the angular frequency, the phase, and the mean velocity (typically zero).","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"A = 1.0 ## amplitude\nΩ = 2π ## angular frequency\nϕ = π/2 ## phase\nvel = 0  ## mean velocity\nk = OscillatoryDOF(A,Ω,ϕ,vel)","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"Plot the position, velocity, and acceleration","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"plot(t,dof_position.(k.(t)),xlims=(0,Inf),label=\"x\")\nplot!(t,dof_velocity.(k.(t)),label=\"ẋ\")\nplot!(t,dof_acceleration.(k.(t)),label=\"ẍ\")","category":"page"},{"location":"manual/dofmotions/#Smooth-ramp-motion","page":"Behaviors of degrees of freedom","title":"Smooth ramp motion","text":"","category":"section"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"To ramp the position from one value to another, we use the SmoothRampDOF. For this, we need to specify the nominal velocity of the ramp, the change in position, and the time at which the ramp starts. There is an optional argument ramp to control the ramp's smoothness. It defaults to EldredgeRamp(11.0), an Eldredge-type ramp with smoothness factor 11.","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"vel = 1.0  ## nominal ramp velocity\nΔx = 1.0 ## change in position\nt0 = 1.0 ## time of ramp start\nk = SmoothRampDOF(vel,Δx,t0)","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"Plot the position","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"plot(t,dof_position.(k.(t)),xlims=(0,Inf),label=\"x\")","category":"page"},{"location":"manual/dofmotions/#User-defined-motion","page":"Behaviors of degrees of freedom","title":"User-defined motion","text":"","category":"section"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"The user can specify the time-varying position by supplying a function of time and using CustomDOF. It automatically differentiates this function to get velocity and acceleration. For example, a quadratic behavior","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"f(t) = 1.0*t + 2.0*t^2\nk = CustomDOF(f)","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"Plot the position","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"plot(t,dof_position.(k.(t)),xlims=(0,Inf),label=\"x\")","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"and the velocity","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"plot(t,dof_velocity.(k.(t)),xlims=(0,Inf),label=\"ẋ\")","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"and the acceleration","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"plot(t,dof_acceleration.(k.(t)),xlims=(0,Inf),label=\"ẍ\")","category":"page"},{"location":"manual/dofmotions/#Exogenous-and-unconstrained-behaviors","page":"Behaviors of degrees of freedom","title":"Exogenous and unconstrained behaviors","text":"","category":"section"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"If the degree of freedom is to be exogenous or unconstrained, then it can be designated as such, e.g,","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"k = ExogenousDOF()","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"or","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"k = UnconstrainedDOF()","category":"page"},{"location":"manual/dofmotions/#Degree-of-freedom-functions","page":"Behaviors of degrees of freedom","title":"Degree of freedom functions","text":"","category":"section"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"ConstantVelocityDOF\nOscillatoryDOF\nSmoothRampDOF\nCustomDOF\nExogenousDOF\nUnconstrainedDOF\ndof_position\ndof_velocity\ndof_acceleration","category":"page"},{"location":"manual/dofmotions/#RigidBodyTools.ConstantVelocityDOF","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.ConstantVelocityDOF","text":"ConstantVelocityDOF(ẋ0::Float64) <: AbstractPrescribedDOFKinematics\n\nSet kinematics with constant velocity ẋ0.\n\n\n\n\n\n","category":"type"},{"location":"manual/dofmotions/#RigidBodyTools.OscillatoryDOF","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.OscillatoryDOF","text":"OscillatoryDOF(amp,angfreq,phase,ẋ0) <: AbstractPrescribedDOFKinematics\n\nSet sinusoidal kinematics with amplitude amp, angular frequency angfreq, phase phase, and mean velocity ẋ0. The function it provides is x(t) = ẋ0*t + amp*sin(angfreq*t+phase).\n\n\n\n\n\n","category":"type"},{"location":"manual/dofmotions/#RigidBodyTools.SmoothRampDOF","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.SmoothRampDOF","text":"SmoothRampDOF(ẋ0,Δx,t0[;ramp=EldredgeRamp(11.0)]) <: AbstractPrescribedDOFKinematics\n\nKinematics describing a smooth ramp change in position Δx starting at time t0 with nominal rate ẋ0. The optional ramp argument is assumed to be given by the smooth ramp EldredgeRamp with a smoothness factor of 11 (larger values lead to sharper transitions on/off the ramp), but this can be replaced by another Eldredge ramp with a different value or a ColoniusRamp.\n\n\n\n\n\n","category":"type"},{"location":"manual/dofmotions/#RigidBodyTools.CustomDOF","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.CustomDOF","text":"CustomDOF(f::Function) <: AbstractPrescribedDOFKinematics\n\nSet custom kinematics for a degree of freedom with a function f that specifies its value at any given time.\n\n\n\n\n\n","category":"type"},{"location":"manual/dofmotions/#RigidBodyTools.ExogenousDOF","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.ExogenousDOF","text":"ExogenousDOF() <: AbstractDOFKinematics\n\nSets a DOF as constrained, but with its behavior set by an exogenous process at every instant. For such a DOF, one must provide a vector  [x,ẋ,ẍ].\n\n\n\n\n\n","category":"type"},{"location":"manual/dofmotions/#RigidBodyTools.UnconstrainedDOF","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.UnconstrainedDOF","text":"UnconstrainedDOF([f::Function]) <: AbstractDOFKinematics\n\nSets a DOF as unconstrained, so that its behavior is either completely free or determined by a given force response (e.g., spring and/or damper). This force response is set by the optional input function f. The signature of f must be f(x,xdot,t), where x and xdot are the position of the dof and its derivative, respectively, and t is the current time. It must return a single scalar, serving as a force or torque for that DOF.\n\n\n\n\n\n","category":"type"},{"location":"manual/dofmotions/#RigidBodyTools.dof_position","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.dof_position","text":"dof_position(kd::DOFKinematicData) -> Float64\n\nReturns the position of the given kinematic data of the degree of freedom\n\n\n\n\n\n","category":"function"},{"location":"manual/dofmotions/#RigidBodyTools.dof_velocity","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.dof_velocity","text":"dof_velocity(kd::DOFKinematicData) -> Float64\n\nReturns the velocity of the given kinematic data of the degree of freedom\n\n\n\n\n\n","category":"function"},{"location":"manual/dofmotions/#RigidBodyTools.dof_acceleration","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.dof_acceleration","text":"dof_acceleration(kd::DOFKinematicData) -> Float64\n\nReturns the acceleration of the given kinematic data of the degree of freedom\n\n\n\n\n\n","category":"function"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"","category":"page"},{"location":"manual/dofmotions/","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"This page was generated using Literate.jl.","category":"page"}]
}
