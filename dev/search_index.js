var documenterSearchIndex = {"docs":
[{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"EditURL = \"<unknown>/literate/bodylists.jl\"","category":"page"},{"location":"manual/bodylists/#Lists-of-bodies","page":"Lists of bodies","title":"Lists of bodies","text":"","category":"section"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"CurrentModule = RigidBodyTools","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"We might want to have several distinct bodies. Here, we discuss how to combine bodies into lists, and similarly, their motions and transforms.","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"using RigidBodyTools\nusing Plots","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"Once again, we will use our animation macro:","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"macro animate_motion(b,m,dt,tmax,xlim,ylim)\n    return esc(quote\n            bc = deepcopy($b)\n            t0, x0 = 0.0, motion_state(bc,$m)\n            x = copy(x0)\n            @gif for t in t0:$dt:t0+$tmax\n                global x += motion_velocity(bc,$m,t)*$dt\n                update_body!(bc,x,$m)\n                plot(bc,xlim=$xlim,ylim=$ylim)\n            end every 5\n        end)\nend","category":"page"},{"location":"manual/bodylists/#Body-list","page":"Lists of bodies","title":"Body list","text":"","category":"section"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"Suppose we have two bodies and we wish to combine them into a single list. The advantage of doing so is that many of the operations we have presented previously also extend to lists. We use BodyList to combine them.","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"b1 = Circle(1.0,0.02)\nb2 = Rectangle(1.0,2.0,0.02)\nbl = BodyList([b1,b2])","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"Another way to do this is to push each one onto the list:","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"bl = BodyList()\npush!(bl,b1)\npush!(bl,b2)","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"We can transform the list by creating a list of transforms with a RigidTransformList","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"T1 = RigidTransform((2.0,3.0),0.0)\nT2 = RigidTransform((-2.0,-0.5),π/4)\ntl = RigidTransformList([T1,T2])","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"The transform list can be applied to the whole body list simply with","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"tl(bl)","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"Let's see our effect","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"plot(bl)","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"It is important to note that the list points to the original bodies, so that any change made to the list is reflected in the original bodies, e.g.","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"plot(b2)","category":"page"},{"location":"manual/bodylists/#Utilities-on-lists","page":"Lists of bodies","title":"Utilities on lists","text":"","category":"section"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"There are some specific utilities that are helpful for lists. For example, to collect all of the x, y points (the segment midpoints) in the list into two vectors, use","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"x, y = collect(bl)","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"In a vector comprising data on these concatenated surface points, we can use view to look at just one body's part and change it:","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"f = zero(x)\nf1 = view(f,bl,1)\nf1 .= 1.0;\nplot(f)","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"Also, we can sum up the values for one of the bodies:","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"sum(f,bl,2)","category":"page"},{"location":"manual/bodylists/#Motion-lists","page":"Lists of bodies","title":"Motion lists","text":"","category":"section"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"Motions can also be assembled into lists, and most of the operations on them extend to lists. Let's create a list of motions: one for body 1 and one for body 2.","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"ufcn(x,y,t) = 0.25*x*y*cos(t)\nvfcn(x,y,t) = 0.25*(x^2-y^2)*cos(t)\nm1 = DeformationMotion(ufcn,vfcn)\nΩ = 1.0\nkin = RotationalOscillation(Ω,π/4,0.0)\nm2 = RigidBodyMotion(kin)\nml = MotionList([m1,m2]);\nnothing #hide","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"Now let's see it in action","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"@animate_motion bl ml π/100 4π (-5,5) (-5,5)","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"We can also use the surface_velocity! function to get the velocities of all surface points in the list. For example, to get them for this previous list at time t = 10","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"x, y = collect(bl)\nu, v = zero(x), zero(y)\nt = 1.0\nsurface_velocity!(u,v,bl,ml,t)","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"We can determine the maximum velocity across the whole set of bodies:","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"umax, i, tmax, bmax = maxlistvelocity(bl,ml)","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"In this case, the maximum velocity occurs at t = 0 on body 2, index 301.","category":"page"},{"location":"manual/bodylists/#Body-list-functions","page":"Lists of bodies","title":"Body list functions","text":"","category":"section"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"BodyList\ngetrange\nBase.collect(::BodyList)\nBase.sum(::AbstractVector,::BodyList,::Int)\nBase.view(::AbstractVector,::BodyList,::Int)\nMotionList\nRigidTransformList\nBase.vec(::RigidTransformList)","category":"page"},{"location":"manual/bodylists/#RigidBodyTools.BodyList","page":"Lists of bodies","title":"RigidBodyTools.BodyList","text":"BodyList([b1,b2,...])\n\nCreate a list of bodies\n\n\n\n\n\n","category":"type"},{"location":"manual/bodylists/#RigidBodyTools.getrange","page":"Lists of bodies","title":"RigidBodyTools.getrange","text":"getrange(bl::BodyList,i::Int) -> Range\n\nReturn the subrange of indices in the global set of surface point data corresponding to body i in a BodyList bl.\n\n\n\n\n\ngetrange(bl::BodyList,ml::MotionList,i::Int) -> Range\n\nReturn the subrange of indices in the global vector of motion state data corresponding to body i in a BodyList bl with corresponding motion list ml.\n\n\n\n\n\n","category":"function"},{"location":"manual/bodylists/#Base.collect-Tuple{BodyList}","page":"Lists of bodies","title":"Base.collect","text":"collect(bl::bodylist[,endpoints=false][,ref=false]) -> Vector{Float64}, Vector{Float64}\n\nCollect the inertial-space coordinates of all of the Lagrange points comprising the bodies in body list bl and return each assembled set of coordinates as a vector. By default, endpoints=false and ref=false, which means this collects the midpoints of segments in the inertial coordinates. If endpoints=true it collects segment endpoints instead. If ref=true it collects the coordinates in the body coordinate system.\n\n\n\n\n\n","category":"method"},{"location":"manual/bodylists/#Base.sum-Tuple{AbstractVector, BodyList, Int64}","page":"Lists of bodies","title":"Base.sum","text":"sum(f::AbstractVector,bl::BodyList,i::Int) -> Real\n\nCompute a sum of the elements of vector f corresponding to body i in body list bl.\n\n\n\n\n\n","category":"method"},{"location":"manual/bodylists/#Base.view-Tuple{AbstractVector, BodyList, Int64}","page":"Lists of bodies","title":"Base.view","text":"view(f::AbstractVector,bl::BodyList,i::Int) -> SubArray\n\nProvide a view of the range of values in vector f corresponding to the Lagrange points of the body with index i in a BodyList bl.\n\n\n\n\n\n","category":"method"},{"location":"manual/bodylists/#RigidBodyTools.MotionList","page":"Lists of bodies","title":"RigidBodyTools.MotionList","text":"MotionList([m1,m2,...])\n\nCreate a list of motions\n\n\n\n\n\n","category":"type"},{"location":"manual/bodylists/#RigidBodyTools.RigidTransformList","page":"Lists of bodies","title":"RigidBodyTools.RigidTransformList","text":"RigidTransformList([t1,t2,...])\n\nCreate a list of rigid transforms\n\n\n\n\n\n","category":"type"},{"location":"manual/bodylists/#Base.vec-Tuple{RigidTransformList}","page":"Lists of bodies","title":"Base.vec","text":"vec(tl::RigidTransformList) -> Vector{Float64}\n\nReturns a concatenation of length-3 vectors of the form [x,y,α] corresponding to the translation and rotation specified by the given by the list of transforms tl.\n\n\n\n\n\n","category":"method"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"","category":"page"},{"location":"manual/bodylists/","page":"Lists of bodies","title":"Lists of bodies","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"EditURL = \"<unknown>/literate/shapes.jl\"","category":"page"},{"location":"manual/shapes/#Creating-and-transforming-bodies","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"","category":"section"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"CurrentModule = RigidBodyTools","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"The most basic functions of this package create an object of type Body. There are a variety of such functions, a few of which we will demonstrate here. Generally speaking, we are interesting in creating the object and placing it in a certain position and orientation. We do this in two steps: we create the basic shape, centered at the origin with a default orientation, and then we transform the shape to a desired location and orientation using a RigidTransform.","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"It is useful to stress that each body stores two types of points internally: the endpoints of the segments that comprise the body surface, and the midpoints of these segments. The midpoints are intended for use in downstream calculations, e.g. as forcing points in the calculations on immersed layers. The midpoints are simply the geometric averages of the endpoints, so endpoints are the ones that are transformed first, and midpoints are updated next.","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"using RigidBodyTools\nusing Plots","category":"page"},{"location":"manual/shapes/#Creating-a-shape","page":"Creating and transforming bodies","title":"Creating a shape","text":"","category":"section"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"Let's first create a shape. For any shape, we have to make a choice of the geometric dimensions (e.g, radius of the circle, side lengths of a rectangle), as well as the points that we use to discretely represent the surface. For this latter choice, there are two constructor types: we can specify the number of points (as an integer), or we can specify the nominal spacing between points (as a floating-point number).","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"The second approach is usually preferable when we use these tools for constructing immersed bodies. It is important to stress that the algorithms for placing points attempt to make the spacing as uniform as possible.","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"Let's create the most basic shape, a circle of radius 1. We will discretize it with 100 points first:","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"b = Circle(1.0,100)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"Now we will create the same body with a spacing of 0.02","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"b = Circle(1.0,0.02)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"This choice led to 312 points along the circumference. Quick math will tell you that the point spacing is probably not exactly 0.02. In fact, you can find out the actual spacing with dlengthmid. This function calculates the spacing associated with each point. (It does so by first calculating the spacing between midpoints between each point and its two adjacent points.)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"dlengthmid(b)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"It is just a bit larger than 0.02.","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"A few other useful functions on the shape. To simply know the number of points,","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"length(b)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"To find the outward normal vectors (based on the perpendicular to the line joining the adjacent midpoints):","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"nx, ny = normalmid(b)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"We can also plot the shape","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"plot(b)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"Sometimes we don't want to fill in the shape (and maybe change the line color). In that case, we can use","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"plot(b,fill=:false,linecolor=:black)","category":"page"},{"location":"manual/shapes/#Transforming-the-shape","page":"Creating and transforming bodies","title":"Transforming the shape","text":"","category":"section"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"Now, suppose we wish to place a shape at a different spot, with a different orientation. For this example, we will use a rectangle, since circles aren't much help for demonstrating orientation changes.","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"b = Rectangle(2.0,1.0,0.02)\nplot(b)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"Okay, now let's place it at (-1,-3), with an angle of π/3. We first create a RigidTransform.","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"T = RigidTransform((-1.0,-3.0),π/3)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"Now we apply this operator. The object T is function-like, and modifies the body in place:","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"T(b)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"Now b is transformed. Let's plot it:","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"plot(b)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"There is an important thing to stress here. Each body keeps two sets of coordinates for the surface points. One that describe the shape in the original configuration, which we will refer to as the body coordinate system (or reference coordinates), and another set that describes the shape in the inertial coordinate system, which we, the viewers, are in. Only the second set of coordinates have been changed by the transform.","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"This also means that, when we apply another transform to the body, it is not a composite operation; it applies the transform to the reference shape, not the current shape.","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"Sometimes we need information about the normals in the reference system. For these, we can use normalmid with the flag ref=true:","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"nx, ny = normalmid(b,ref=true)","category":"page"},{"location":"manual/shapes/#Other-shapes","page":"Creating and transforming bodies","title":"Other shapes","text":"","category":"section"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"Let's see some other shapes in action, like a square and an ellipse","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"b1, b2 = Square(1.0,0.02), Ellipse(0.6,0.1,0.02)\nplot(plot(b1), plot(b2))","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"A NACA 4412 airfoil, with chord length 1, and 0.02 spacing between points, which we will place at 20 degrees angle of attack","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"b = NACA4(0.04,0.4,0.12,0.02)\nT = RigidTransform((0.0,0.0),-20π/180)\nT(b)\nplot(b)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"A flat plate with no thickness, at 45 degrees angle of attack","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"b = Plate(1.0,0.02)\nT = RigidTransform((0.0,0.0),-45π/180)\nT(b)\nplot(b)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"and a flat plate with a 5 percent thickness (and rounded ends)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"b = ThickPlate(1.0,0.05,0.01)\nplot(b)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"There are also some generic tools for creating shapes. A BasicBody simply consists of points that describe the vertices. The interface for this is very simple.","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"x = [1.0, 1.2, 0.7, 0.6, 0.2, -0.1, 0.1, 0.4]\ny = [0.1, 0.5, 0.8, 1.2, 0.8, 0.6, 0.2, 0.3]\nb = BasicBody(x,y)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"plot(b)\nscatter!(b,markersize=3,markercolor=:black)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"However, this function does not insert any points along the sides between vertices. We have to do the work of specifying these points in the original call. For this reason, there are a few functions that are more directly useful. For example, we can create a polygon from these vertices, with a specified spacing between points distributed along the polygon sides","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"b = Polygon(x,y,0.02)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"plot(b)\nscatter!(b,markersize=3,markercolor=:black)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"Alternatively, we can interpret those original points as control points for splines, with a spacing between points along the splines provided:","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"b = SplinedBody(x,y,0.02)","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"plot(b)\nscatter!(b,markersize=3,markercolor=:black)","category":"page"},{"location":"manual/shapes/#Body-functions","page":"Creating and transforming bodies","title":"Body functions","text":"","category":"section"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"BasicBody\nPolygon\nCircle\nEllipse\nNACA4\nPlate\nRectangle\nSplinedBody\nSquare","category":"page"},{"location":"manual/shapes/#RigidBodyTools.BasicBody","page":"Creating and transforming bodies","title":"RigidBodyTools.BasicBody","text":"BasicBody(x,y[,closuretype=ClosedBody]) <: Body\n\nConstruct a body by simply passing in the x and y coordinate vectors. The last point will be automatically connected to the first point. The coordinate vectors are assumed to be expressed in the body-fixed coordinate system. The optional closuretype specifies whether the body is closed (ClosedBody) or open (OpenBody). If closed, then the first and last points are assumed joined in operations that require neighbor points.\n\n\n\n\n\n","category":"type"},{"location":"manual/shapes/#RigidBodyTools.Polygon","page":"Creating and transforming bodies","title":"RigidBodyTools.Polygon","text":"Polygon(x::Vector,y::Vector,n[,closuretype=ClosedBody])\n\nCreate a polygon shape with vertices x and y, with approximately n points distributed along the perimeter.\n\n\n\n\n\n","category":"type"},{"location":"manual/shapes/#RigidBodyTools.Circle","page":"Creating and transforming bodies","title":"RigidBodyTools.Circle","text":"Circle(a,n) <: Body\n\nConstruct a circular body with radius a and with n points distributed on the body perimeter.\n\n\n\n\n\nCircle(a,targetsize::Float64) <: Body\n\nConstruct a circular body with radius a with spacing between points set approximately to targetsize.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.Ellipse","page":"Creating and transforming bodies","title":"RigidBodyTools.Ellipse","text":"Ellipse(a,b,n[,endpointson=false],[shifted=false]) <: Body\n\nConstruct an elliptical body with semi-major axis a and semi-minor axis b, with n points distributed on the body perimeter. Can also call this with Ellipse(a,b,ds) where ds is the desired spacing between points. If endpointson=true, then the endpoints will be placed on the surface and the midpoints will lie inside the nominal ellipse. By default, the midpoints lie on the ellipse. If shifted=true, then the first endpoint lies on an axis of symmetry. By default the first midpoint lies on the axis symmetry.\n\n\n\n\n\n","category":"type"},{"location":"manual/shapes/#RigidBodyTools.NACA4","page":"Creating and transforming bodies","title":"RigidBodyTools.NACA4","text":"NACA4(cam,pos,thick,np,[len=1.0]) <: Body{N}\n\nGenerates points in the shape of a NACA 4-digit airfoil of chord length 1. The relative camber is specified by cam, the position of maximum camber (as fraction of chord) by pos, and the relative thickness by thick. The parameter np specifies the number of points on the upper or lower surface. The optional parameter len specifies the chord length, which defaults to 1.0.\n\nExample\n\njulia> b = NACA4(0.0,0.0,0.12);\n\n\n\n\n\n","category":"type"},{"location":"manual/shapes/#RigidBodyTools.Plate","page":"Creating and transforming bodies","title":"RigidBodyTools.Plate","text":"Plate(a,n) <: Body\n\nConstruct a flat plate of zero thickness with length a, divided into n equal segments.\n\n\n\n\n\nPlate(a,ds) <: Body\n\nConstruct a flat plate of zero thickness with length a, with approximate spacing ds between points.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.Rectangle","page":"Creating and transforming bodies","title":"RigidBodyTools.Rectangle","text":"Rectangle(a,b,n) <: Body\n\nConstruct a rectangular body with x̃ side half-length a and ỹ side half-length b, with approximately n points distributed along the perimeter. The centroid of the rectangle is placed at the origin (so that the lower left corner is at (-a,-b)).\n\nPoints are not placed at the corners, but rather, are shifted by half a segment. This ensures that all normals are perpendicular to the sides.\n\n\n\n\n\nRectangle(a,b,ds) <: Body\n\nConstruct a rectangular body with x̃ side half-length a and ỹ side half-length b, with approximate spacing ds between points.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.SplinedBody","page":"Creating and transforming bodies","title":"RigidBodyTools.SplinedBody","text":"SplinedBody(X,Δx[,closuretype=ClosedBody]) -> BasicBody\n\nUsing control points in X (assumed to be N x 2, where N is the number of points), create a set of points that are uniformly spaced (with spacing Δx) on a curve that passes through the control points. A cubic parametric spline algorithm is used. If the optional parameter closuretype is set to OpenBody, then the end points are not joined together.\n\n\n\n\n\nSplinedBody(x,y,Δx[,closuretype=ClosedBody]) -> BasicBody\n\nUsing control points in x and y, create a set of points that are uniformly spaced (with spacing Δx) on a curve that passes through the control points. A cubic parametric spline algorithm is used. If the optional parameter closuretype is set to OpenBody, then the end points are not joined together.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.Square","page":"Creating and transforming bodies","title":"RigidBodyTools.Square","text":"Square(a,n) <: Body\n\nConstruct a square body with side half-length a and with approximately n points distributed along the perimeter.\n\n\n\n\n\nSquare(a,ds) <: Body\n\nConstruct a square body with side half-length a, with approximate spacing ds between points.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#Rigid-transformations-of-shapes","page":"Creating and transforming bodies","title":"Rigid transformations of shapes","text":"","category":"section"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"RigidTransform\nBase.vec(::RigidTransform)","category":"page"},{"location":"manual/shapes/#RigidBodyTools.RigidTransform","page":"Creating and transforming bodies","title":"RigidBodyTools.RigidTransform","text":"RigidTransform(x::Tuple{Real,Real},α::Real)\n\nConstruct a rigid-body transform operator, with rotation by angle α and translation specified by x. The translation coordinates are specified in the target coordinate system.\n\nThe resulting transform can be used as an operator on pairs of coordinate vectors, x and y, or on bodies. For transformation of bodies, it only overwrites the x and y fields of the body, but leaves the x̃ and ỹ (body coordinates) intact.\n\nThe translation can be provided as either a tuple (x,y) or as a complex number.\n\nConstructors\n\nRigidTransform((x,y),α)\nRigidTransform(u::Vector{Real})\nRigidTransform(u::NTuple{3,Real})\nRigidTransform.(u) where u is a collection of vectors or tuples.\n\nExample\n\njulia> body = RigidTransform.Ellipse(0.5,0.1,100)\nElliptical body with 100 points and semi-axes (0.5,0.1)\n   Current position: (0.0,0.0)\n   Current angle (rad): 0.0\n\njulia> T = RigidTransform((1.0,1.0),π/4)\nRigid-body transform\n  Translation: (1.0,1.0)\n  Rotation angle (rad): 0.7853981633974483\n\njulia> T(body)\nElliptical body with 100 points and semi-axes (0.5,0.1)\n   Current position: (1.0,1.0)\n   Current angle (rad): 0.7853981633974483\n\n\n\n\n\n","category":"type"},{"location":"manual/shapes/#Base.vec-Tuple{RigidTransform}","page":"Creating and transforming bodies","title":"Base.vec","text":"vec(T::RigidTransform) -> Vector{Float64}\n\nReturns a length-3 vector of the form [x,y,α] corresponding to the translation and rotation specified by the given transform T.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#Shape-utilities","page":"Creating and transforming bodies","title":"Shape utilities","text":"","category":"section"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"centraldiff\nBase.diff(::Body)\nBase.diff(::BodyList)\ndlength\ndlengthmid\nBase.length(::Body)\nmidpoints(::Body)\nmidpoints(::BodyList)\nnormal\nnormalmid\narccoord\narccoordmid\narclength(::Body)\narclength(::BodyList)","category":"page"},{"location":"manual/shapes/#RigidBodyTools.centraldiff","page":"Creating and transforming bodies","title":"RigidBodyTools.centraldiff","text":"centraldiff(body::Body[,ref=false]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the circular central differences of coordinates on body body (or on each body in list body). If ref=true, uses the reference coordinates in body-fixed space.\n\n\n\n\n\ncentraldiff(bl::BodyList[,ref=false]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the centraldiff on each constituent body in bl.  If ref=true, uses the reference coordinates in body-fixed space.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#Base.diff-Tuple{Body}","page":"Creating and transforming bodies","title":"Base.diff","text":"diff(body::Body[,ref=false]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the x and y differences of the faces on the perimeter of body body, whose ends are at the current x and y coordinates (in inertial space) of the body (if ref=false), or at the reference x̃ and ỹ coordinates (body-fixed space) if ref=true. Face 1 corresponds to the face between points 1 and 2, for example.\n\nIf body is a BodyList, then it computes the differences separately on each constituent body.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#Base.diff-Tuple{BodyList}","page":"Creating and transforming bodies","title":"Base.diff","text":"diff(bl::BodyList[,ref=false]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the diff on each constituent body in bl.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#RigidBodyTools.dlength","page":"Creating and transforming bodies","title":"RigidBodyTools.dlength","text":"dlength(body::Body/BodyList[,ref=false]) -> Vector{Float64}\n\nCompute the lengths of the faces on the perimeter of body body, whose ends are at the current xend and yend coordinates (in inertial space) of the body. Face 1 corresponds to the face between endpoints 1 and 2, for example. If ref=true, uses the reference coordinates in body-fixed space.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.dlengthmid","page":"Creating and transforming bodies","title":"RigidBodyTools.dlengthmid","text":"dlengthmid(body::Body/BodyList[,ref=false]) -> Vector{Float64}\n\nSame as dlength.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#Base.length-Tuple{Body}","page":"Creating and transforming bodies","title":"Base.length","text":"length(body::Body)\n\nReturn the number of points on the body perimeter\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#RigidBodyTools.midpoints-Tuple{Body}","page":"Creating and transforming bodies","title":"RigidBodyTools.midpoints","text":"midpoints(body::Body[,ref=false]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the x and y midpoints of the faces on the perimeter of body body, whose ends are at the current x and y coordinates (in inertial space) of the body (if ref=false), or at the reference x̃ and ỹ coordinates (body-fixed space) if ref=true. Face 1 corresponds to the face between points 1 and 2, for example.\n\nIf body is a BodyList, then it computes the differences separately on each constituent body.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#RigidBodyTools.midpoints-Tuple{BodyList}","page":"Creating and transforming bodies","title":"RigidBodyTools.midpoints","text":"midpoints(bl::BodyList[,ref=false]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the midpoints on each constituent body in bl.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#RigidBodyTools.normal","page":"Creating and transforming bodies","title":"RigidBodyTools.normal","text":"normal(body::Body/BodyList[,ref=false]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the current normals in inertial components (if ref=false) or body-   fixed components (if ref=true) of the faces on the perimeter of body body, whose ends are at the current xend and yend coordinates (in inertial space) of the body. Face 1 corresponds to the face between points 1 and 2, for example. For an OpenBody, this provides a vector that is one element shorter than the number of points.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.normalmid","page":"Creating and transforming bodies","title":"RigidBodyTools.normalmid","text":"normalmid(body::Body/BodyList[,ref=false]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the current normals in inertial components (if ref=false) or body-   fixed components (if ref=true) of the faces formed between endpoints on the perimeter of body body (or each body in list body).\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.arccoord","page":"Creating and transforming bodies","title":"RigidBodyTools.arccoord","text":"arccoord(body::Body/BodyList[,ref=false]) -> Vector{Float64}\n\nReturns a vector containing the arclength coordinate along the surface of body, evaluated at the second endpoint of each face. So, e.g., the first coordinate would be the length of face 1, the second the length of face 2, and the last would be total length of all of the faces. Use inertial components (if ref=false) or body-fixed components (if ref=true). If this is a body list, restart the origin of the coordinates on each body in the list.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.arccoordmid","page":"Creating and transforming bodies","title":"RigidBodyTools.arccoordmid","text":"arccoordmid(body::Body/BodyList[,ref=false]) -> Vector{Float64}\n\nReturns a vector containing the arclength coordinate along the surface of body, evaluated at the midpoints between the ends of faces. So, e.g., the first coordinate would be half of the length of face 1, the second would be half of face 2 plus all of face 1, etc. Use inertial components (if ref=false) or body-   fixed components (if ref=true). If this is a body list, restart   the origin of the coordinates on each body in the list.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.arclength-Tuple{Body}","page":"Creating and transforming bodies","title":"RigidBodyTools.arclength","text":"arclength(body::Body[,ref=false])\n\nCompute the total arclength of body, from the sum of the lengths of the faces. If ref=true, use the body-fixed coordinates.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#RigidBodyTools.arclength-Tuple{BodyList}","page":"Creating and transforming bodies","title":"RigidBodyTools.arclength","text":"arclength(bl::BodyList[,ref=false]) -> Vector{Float64}\n\nCompute the total arclength of each body in bl and assemble the results into a vector. If ref=true, use the body-fixed coordinates.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"","category":"page"},{"location":"manual/shapes/","page":"Creating and transforming bodies","title":"Creating and transforming bodies","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"EditURL = \"<unknown>/literate/motions.jl\"","category":"page"},{"location":"manual/motions/#Making-bodies-move","page":"Making bodies move","title":"Making bodies move","text":"","category":"section"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"CurrentModule = RigidBodyTools","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"For many applications we wish to specify the motion of a body. Motions come in two forms: rigid-body motions, in which the body moves as a rigid unit; and deformations, in which the surface's shape is altered. These two types of motions can also be combined.","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"using RigidBodyTools\nusing Plots","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"Before we get started, let's define a macro that can help us animate the motions we will be creating","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"macro animate_motion(b,m,dt,tmax,xlim,ylim)\n    return esc(quote\n            bc = deepcopy($b)\n            t0, x0 = 0.0, motion_state(bc,$m)\n            x = copy(x0)\n            @gif for t in t0:$dt:t0+$tmax\n                global x += motion_velocity(bc,$m,t)*$dt\n                update_body!(bc,x,$m)\n                plot(bc,xlim=$xlim,ylim=$ylim)\n            end every 5\n        end)\nend","category":"page"},{"location":"manual/motions/#Rigid-body-motions","page":"Making bodies move","title":"Rigid-body motions","text":"","category":"section"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"We will start with rigid-body motions. These are created with the RigidBodyMotion constructor. For these, we have a variety of kinematics classes, which allow us to constrain the motion in particular ways. The most basic of these is just constant translational and rotational motion:","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"m = RigidBodyMotion((1.0,2.0),π/2)","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"Let's demonstrate this on a rectangular body","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"b = Rectangle(1.0,0.5,0.02)\n@animate_motion b m 0.01 2.0 (-2,5) (-2,5)","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"Notice that the animation macro makes use of three key functions: motion_state, motion_velocity, and update_body!. These are used frequently:","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"motion_state(b,m) returns the state vector that describes the body motion\nmotion_velocity(b,m,t) returns the rate of change of the state vector at time t\nupdate_body!(b,x,m) updates the body with the state vector x.","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"There is one more function that is useful for some downstream application: surface_velocity!(u,v,b,m,t) provides the surface velocity components u and v in the inertial coordinate system, at the midpoints of the surface segments.","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"We can also set a different center of rotation with the pivot keyword argument. Here, we remove the translation and set a center of rotation at (0,-1).","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"m = RigidBodyMotion((0.0,0.0),π/2;pivot = (0.0,-1.0))\n@animate_motion b m 0.01 4.0 (-3,3) (-4,2)","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"Let's try something more interesting. We will use a pitch-up maneuver on a thick plate. This pitches up about the leading edge to 45 degrees, at a pitch rate of 0.2 (the ratio dotalphac2U_0), where c is the length of the plate. The forward velocity U_0 is set to 1.","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"kin = Pitchup(1.0,0.5,0.2,0.0,0.5,π/4)\nm = RigidBodyMotion(kin)\nb = ThickPlate(1.0,0.05,0.02)\n@animate_motion b m 0.01 3.0 (-1,5) (-1,1)","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"There are a number of other types of kinematics, particularly those with oscillatory behavior: OscillationX, OscillationY, RotationalOscillation, OscillationXY, PitchHeave, Oscillation. Each one is documented.","category":"page"},{"location":"manual/motions/#Deforming-bodies","page":"Making bodies move","title":"Deforming bodies","text":"","category":"section"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"For deforming bodies, we specify the motion of the surface directly. This deformation velocity is expressed in the coordinate system attached to the body, rather than our inertial coordinate system. This enables the motion to be easily superposed with the rigid-body motion described above.","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"It is also important to note that the motion is applied to the endpoints of the surface segments. The midpoints are then constructed from the updated endpoints. Let's see an example. We will create an oscillatory deformation of a circle. We create the motion by creating functions for each component of velocity.","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"ufcn(x,y,t) = 0.25*x*y*cos(t)\nvfcn(x,y,t) = 0.25*(x^2-y^2)*cos(t)\nm = DeformationMotion(ufcn,vfcn)","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"Now create the body and visualize the motion","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"b = Circle(1.0,0.02)\n@animate_motion b m π/100 4π (-2,2) (-2,2)","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"There is a more basic type of deformation motion: ConstantDeformationMotion, which is not time varying, but simply a constant vector for each surface (end) point. Let's make the circle expand radially at constant velocity","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"u = copy(b.x̃end)\nv = copy(b.ỹend)\nm = ConstantDeformationMotion(u,v)\n@animate_motion b m 0.01 2.0 (-5,5) (-5,5)","category":"page"},{"location":"manual/motions/#Rigid-and-deforming-motions","page":"Making bodies move","title":"Rigid and deforming motions","text":"","category":"section"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"We can easily combine rigid and deforming motions with the use of RigidAndDeformingMotion. Let's make a square oscillate in rotation and undergo oscillatory deformation:","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"b = Square(1.0,0.02)","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"Here is the rotational oscillation, with frequency Omega.","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"Ω = 1.0\nkin = RotationalOscillation(Ω,π/4,0.0)\nmrig = RigidBodyMotion(kin)","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"Here is the deformation.","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"ufcn(x,y,t) = 0.25*(x^2+y^2)*y*cos(Ω*t)\nvfcn(x,y,t) = -0.25*(x^2+y^2)*x*cos(Ω*t)\nmdef = DeformationMotion(ufcn,vfcn)","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"Now put them together with RigidAndDeformingMotion, and animate it:","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"m = RigidAndDeformingMotion(mrig,mdef)\n@animate_motion b m π/100 4π (-2,2) (-2,2)","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"Sometimes it is helpful to know the maximum velocity that a given motion will produce. For this, we can use the function maxvelocity. This also tells us where it will occur on the body, and at what time.","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"umax, i, t = maxvelocity(b,m)","category":"page"},{"location":"manual/motions/#Defining-new-motions","page":"Making bodies move","title":"Defining new motions","text":"","category":"section"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"It is straightforward to define new types of deformation motion that don't fit into the framework shown here. We need only do two things:","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"Create a type as a subtype of AbstractDeformationMotion.\nExtend the function RigidBodyTools.motion_velocity(b,m,t) for your new motion type, so that it returns a concatenated vector of the surface segment endpoint velocity components (in body coordinate system).","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"Let's demonstrate this with an example in which we specify a motion in which only the top of a rectangle will deform. For this, we make use of the side field in the Polygon type: each entry in side describes the range of indices of segment endpoints on each side (including the first vertex).","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"struct TopMotion{UT} <: AbstractDeformationMotion\n    vtop :: UT\nend\n\nfunction RigidBodyTools.motion_velocity(b::Polygon,m::TopMotion,t::Real)\n\n    u, v = zero(b.x̃end), zero(b.ỹend)\n    top = b.side[3]\n    v[top] .= m.vtop.(b.x̃end[top],b.ỹend[top],t)\n    return vcat(u,v)\nend","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"Let's apply a deformation function and see it work:","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"b = Rectangle(1.0,2.0,0.02)\nvfcn(x,y,t) = 0.2*(1-x^2)*cos(t)\nm = TopMotion(vfcn)\n\n@animate_motion b m π/100 4π (-1.5,1.5) (-2.5,2.5)","category":"page"},{"location":"manual/motions/#Motion-types","page":"Making bodies move","title":"Motion types","text":"","category":"section"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"DeformationMotion\nConstantDeformationMotion\nRigidBodyMotion\nRigidBodyMotion(::Kinematics)\nRigidBodyMotion(::Any,::Any)\nRigidAndDeformingMotion\nRigidAndDeformingMotion(::Kinematics,::AbstractDeformationMotion)\nRigidAndDeformingMotion(::Kinematics,::Any,::Any)\nRigidAndDeformingMotion(::Any,::Any,::Any,::Any)","category":"page"},{"location":"manual/motions/#RigidBodyTools.DeformationMotion","page":"Making bodies move","title":"RigidBodyTools.DeformationMotion","text":"DeformationMotion(u::Function,v::Function)\n\nCreate an instance of directly-specified velocity whose components are specified with functions. These functions u and v must each be of the form f(x̃,ỹ,t), where x̃ and ỹ are coordinates of a point in the body coordinate system and t is time, and they must return the corresponding velocity component in the body coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"manual/motions/#RigidBodyTools.ConstantDeformationMotion","page":"Making bodies move","title":"RigidBodyTools.ConstantDeformationMotion","text":"ConstantDeformationMotion(u::Vector{Float64},v::Vector{Float64})\n\nCreate an instance of basic directly-specified (constant) velocity, to be associated with a body whose length is the same as u and v.\n\n\n\n\n\n","category":"type"},{"location":"manual/motions/#RigidBodyTools.RigidBodyMotion","page":"Making bodies move","title":"RigidBodyTools.RigidBodyMotion","text":"RigidBodyMotion <: AbstractMotion\n\nA type to store the body's current kinematics\n\nFields\n\ndata: current kinematic data\nkin: a Kinematics structure\n\nThe first six fields are meant as a cache of the current kinematics while the kin field can be used to find the plate kinematics at any time.\n\n\n\n\n\n","category":"type"},{"location":"manual/motions/#RigidBodyTools.RigidBodyMotion-Tuple{Kinematics}","page":"Making bodies move","title":"RigidBodyTools.RigidBodyMotion","text":"RigidBodyMotion(kin::Kinematics)\n\nCreate an instance of rigid-body motion with kinematics kin.\n\n\n\n\n\n","category":"method"},{"location":"manual/motions/#RigidBodyTools.RigidAndDeformingMotion","page":"Making bodies move","title":"RigidBodyTools.RigidAndDeformingMotion","text":"RigidAndDeformingMotion(rig::RigidBodyMotion,def::AbstractDeformationMotion)\n\nCreate an instance of basic superposition of a rigid-body motion and directly-specified deformation velocity in body coordinates.\n\n\n\n\n\n","category":"type"},{"location":"manual/motions/#RigidBodyTools.RigidAndDeformingMotion-Tuple{Kinematics, AbstractDeformationMotion}","page":"Making bodies move","title":"RigidBodyTools.RigidAndDeformingMotion","text":"RigidAndDeformingMotion(kin::Kinematics,def::AbstractDeformationMotion)\n\nCreate an instance of basic superposition of a rigid-body motion with kinematics kin, and directly-specified deformation velocity in body coordinates.\n\n\n\n\n\n","category":"method"},{"location":"manual/motions/#RigidBodyTools.RigidAndDeformingMotion-Tuple{Kinematics, Any, Any}","page":"Making bodies move","title":"RigidBodyTools.RigidAndDeformingMotion","text":"RigidAndDeformingMotion(kin::Kinematics,ũ::Vector{Float64},ṽ::Vector{Float64})\n\nCreate an instance of basic superposition of a rigid-body motion and directly-specified (constant) deformation velocity in body coordinates, to be associated with a body whose length is the same as ũ and ṽ.\n\n\n\n\n\n","category":"method"},{"location":"manual/motions/#RigidBodyTools.RigidAndDeformingMotion-NTuple{4, Any}","page":"Making bodies move","title":"RigidBodyTools.RigidAndDeformingMotion","text":"RigidAndDeformingMotion(ċ,α̇,ũ::Vector{Float64},ṽ::Vector{Float64})\n\nSpecify constant translational ċ and angular α̇ velocity and directly-specified (constant) deformation velocity in body coordinates, to be associated with a body whose length is the same as ũ and ṽ.\n\n\n\n\n\n","category":"method"},{"location":"manual/motions/#Surface-and-motion-velocity-functions","page":"Making bodies move","title":"Surface and motion velocity functions","text":"","category":"section"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"motion_state\nupdate_body!\nmotion_velocity\nsurface_velocity!\nsurface_velocity\nmaxvelocity","category":"page"},{"location":"manual/motions/#RigidBodyTools.motion_state","page":"Making bodies move","title":"RigidBodyTools.motion_state","text":"motion_state(b::Body,m::RigidBodyMotion)\n\nReturn the current state vector of body b associated with rigid body motion m. It returns the current coordinates of the body centroid and the angle of the body.\n\n\n\n\n\nmotion_state(b::Body,m::AbstractDeformationMotion)\n\nReturn the current state vector of body b associated with direct motion m. It returns the concatenated coordinates of the body surface (in the body-fixed coordinate system).\n\n\n\n\n\nmotion_state(b::Body,m::RigidAndDeformingMotion)\n\nReturn the current state vector of body b associated with rigid+direct motion m. It returns the concatenated coordinates of the rigid-body mode and the body surface (in the body coordinate system).\n\n\n\n\n\nmotion_state(bl::BodyList,ml::MotionList)\n\nReturn the current state vector of body list bl associated with motion list ml. It returns the aggregated state vectors of each body.\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.update_body!","page":"Making bodies move","title":"RigidBodyTools.update_body!","text":"update_body!(b::Body,x::AbstractVector,m::RigidBodyMotion)\n\nUpdate body b with the rigid-body motion state vector x. The information in m is used for checking lengths only.\n\n\n\n\n\nupdate_body!(b::Body,x::AbstractVector,m::AbstractDeformationMotion)\n\nUpdate body b with the motion state vector x, interpreted as coordinates in the body coordinate system. The information in m is used for parsing only.\n\n\n\n\n\nupdate_body!(b::Body,x::AbstractVector,m::RigidAndDeformingMotion)\n\nUpdate body b with the motion state vector x. The part of the motion state associated with surface deformation is interpreted as expressed in body coordinates. The information in m is used for parsing only.\n\n\n\n\n\nupdate_body!(bl::BodyList,x::AbstractVector,ml::MotionList)\n\nUpdate the bodies in list bl with the given motion state vector x. The argument ml simply provides the information needed to parse the vector into each body.\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.motion_velocity","page":"Making bodies move","title":"RigidBodyTools.motion_velocity","text":"motion_velocity(b::Body,m::RigidBodyMotion,t::Real)\n\nReturn the velocity components (as a vector) of a RigidBodyMotion at the given time t.\n\n\n\n\n\nmotion_velocity(b::Body,m::ConstantDeformationMotion,t::Real)\n\nReturn the velocity components (as a vector) of a BasicDirectMotion at the given time t. These specify the velocities (in body cooordinates) of the surface segments endpoints.\n\n\n\n\n\nmotion_velocity(b::Body,m::RigidAndDeformingMotion,t::Real)\n\nReturn the velocity components (as a vector) of a RigidAndDeformingMotion at the given time t.\n\n\n\n\n\nmotion_velocity(bl::BodyList,ml::MotionList,t::Real) -> Vector\n\nReturn the aggregated velocity components (as a vector) of a MotionList at the given time t.\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.surface_velocity!","page":"Making bodies move","title":"RigidBodyTools.surface_velocity!","text":"surface_velocity!(u::AbstractVector{Float64},v::AbstractVector{Float64},\n             body::Body,motion::AbstractMotion,t::Real[;inertial=true])\n\nAssign the components of body velocity u and v (in inertial coordinate system) at surface positions described by inertial coordinates in body body at time t, based on supplied motions in the motion for the body. If, instead, inertial=false, then it is assumed that u, v and the surface positions in body are all expressed in comoving coordinates (but velocities are relative to inertial   frame).\n\n\n\n\n\nsurface_velocity!(u::AbstractVector{Float64},v::AbstractVector{Float64},\n                 x::AbstractVector{Float64},y::AbstractVector{Float64},\n                 xc::Real,yc::Real,α::Real,\n                 motion::RigidBodyMotion,t::Real[;inertial=true])\n\nAssign the components of rigid body velocity u and v (in inertial coordinate system) at surface positions described by coordinates x, y (also in inertial coordinate system) at time t, based on supplied motion motion for the body. The current position and orientation of the rigid-body coordinate system are supplied as xc, yc, and α. If, instead, inertial=false, then it is assumed that u, v, x, y, xc, yc are all expressed in comoving coordinates (but velocities are relative to inertial   frame).\n\n\n\n\n\nsurface_velocity!(u::AbstractVector{Float64},v::AbstractVector{Float64},\n                 b::Body,motion::AbstractDeformationMotion,t::Real)\n\nAssign the components of velocity u and v (in inertial coordinate system) at surface positions described by x and y points in body b (also in inertial coordinate system) at time t, based on supplied motion motion for the body. This function calls the function motion_velocity associated with the given motion type.\n\n\n\n\n\nsurface_velocity!(u::AbstractVector{Float64},v::AbstractVector{Float64},\n                 b::Body,motion::RigidAndDeformingMotion,t::Real)\n\nAssign the components of velocity u and v (in inertial coordinate system) at surface positions described by points in body b (also in inertial coordinate system) at time t, based on supplied motion motion for the body. This function calls the supplied function for the deformation part in motion.defmotion.\n\n\n\n\n\nsurface_velocity!(u::AbstractVector{Float64},v::AbstractVector{Float64},\n                 bl::BodyList,ml::Union{AbstractMotion,MotionList},t::Real[;inertial=true])\n\nAssign the components of velocity u and v (in inertial coordinate system) at surface positions described by coordinates inertial coordinates in each body in bl at time t, based on supplied motions in the MotionList ml for each body. If only one motion is specified in ml, then it is assumed that   this is to be applied to all bodies.\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.surface_velocity","page":"Making bodies move","title":"RigidBodyTools.surface_velocity","text":"surface_velocity(x::AbstractVector{Float64},y::AbstractVector{Float64},\n                xc::Real,yc::Real,α::Real,motion::RigidBodyMotion,t::Real[;inertial=true])\n\nReturn the components of rigid body velocities (in inertial components) at surface positions described by coordinates x, y (also in inertial coordinate system) at time t, based on supplied motion motion for the body. If, instead, inertial=false, then it is assumed that u, v, x, y, xc, yc are all expressed in comoving coordinates (but velocities are relative to inertial   frame).\n\n\n\n\n\nsurface_velocity(bl::BodyList,ml::Union{AbstractMotion,MotionList},t::Real[;inertial=true])\n\nReturn the components of rigid body velocity (in inertial coordinate system) at surface positions described by coordinates inertial coordinates in each body in bl at time t, based on supplied motions in the MotionList ml for each body. If only one motion is specified in ml, then it is assumed that   this is to be applied to all bodies.\n\n\n\n\n\nsurface_velocity(body::Body,motion::AbstractMotion,t::Real[;inertial=true])\n\nReturn the components of rigid body velocity (in inertial coordinate system) at surface positions described by inertial coordinates in body body at time t, based on supplied motions in motion for the body. If inertial=false, then velocities are computed and body positions are assumed to be in comoving coordinates.\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.maxvelocity","page":"Making bodies move","title":"RigidBodyTools.maxvelocity","text":"maxvelocity(b::Body,m::AbstractMotion[,tmax=100,dt=0.01])\n\nSearch through the given motion m applied to body b and return (umax,i,t), the maximum velocity magnitude, the index of the body points where it occurs, and the time at which it occurs.\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#Rigid-body-kinematics-types","page":"Making bodies move","title":"Rigid body kinematics types","text":"","category":"section"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"Kinematics\nOscillation\nOscillationX\nOscillationY\nOscillationXY\nPitchHeave\nPitchup\nRotationalOscillation\nSwitchedKinematics","category":"page"},{"location":"manual/motions/#RigidBodyTools.Kinematics","page":"Making bodies move","title":"RigidBodyTools.Kinematics","text":"An abstract type for types that takes in time and returns KinematicData(t,c, ċ, c̈, α, α̇, α̈).\n\n\n\n\n\n","category":"type"},{"location":"manual/motions/#RigidBodyTools.Oscillation","page":"Making bodies move","title":"RigidBodyTools.Oscillation","text":"Oscillation(Ux,Uy,α̇₀,ax,ay,Ω,Ax,Ay,ϕx,ϕy,α₀,Δα,ϕα) <: Kinematics\n\nSet 2-d oscillatory kinematics. This general constructor sets up motion of a rotational axis, located at ax, ay (expressed relative to the body centroid, in   a body-fixed coordinate system). The rotational axis motion is described by\n\nx(t) = U_x t + A_xsin(Omega t - phi_x) quad y(t) = U_y t + A_ysin(Omega t - phi_y)  quad alpha(t) = alpha_0 + dotalpha_0 t +  Deltaalpha sin(Omega t - phi_alpha)\n\n\n\n\n\n","category":"type"},{"location":"manual/motions/#RigidBodyTools.OscillationX","page":"Making bodies move","title":"RigidBodyTools.OscillationX","text":"OscillationX(Ux,Ω,Ax,ϕx)\n\nSet oscillatory kinematics in the x direction, of the form\n\nx(t) = U_x t + A_x sin(Omega t - phi_x)\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.OscillationY","page":"Making bodies move","title":"RigidBodyTools.OscillationY","text":"OscillationY(Uy,Ω,Ay,ϕy)\n\nSet oscillatory kinematics in the y direction, of the form\n\ny(t) = U_y t + A_y sin(Omega t - phi_y)\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.OscillationXY","page":"Making bodies move","title":"RigidBodyTools.OscillationXY","text":"OscillationXY(Ux,Uy,Ω,Ax,ϕx,Ay,ϕy)\n\nSet oscillatory kinematics in the x and y directions, of the form\n\nx(t) = U_x t + A_x sin(Omega t - phi_x) quad y(t) = U_y t + A_y sin(Omega t - phi_y)\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.PitchHeave","page":"Making bodies move","title":"RigidBodyTools.PitchHeave","text":"PitchHeave(U₀,a,Ω,α₀,Δα,ϕp,A,ϕh)\n\nCreate oscillatory pitching and heaving kinematics of a pitch axis at location a (expressed relative to the centroid in the tildex direction of the body-fixed coordinate system), of the form (in inertial coordinates)\n\nx(t) = U_0 quad y(t) = Asin(Omega t - phi_h)  quad alpha(t) = alpha_0 + Deltaalpha sin(Omega t - phi_p)\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.Pitchup","page":"Making bodies move","title":"RigidBodyTools.Pitchup","text":"Pitchup(U₀,a,K,α₀,t₀,Δα,ramp=EldredgeRamp(11.0)) <: Kinematics\n\nKinematics describing a pitch-ramp motion (horizontal translation with rotation) starting at time t_0 about an axis at a (expressed relative to the centroid, in the tildex   direction in the body-fixed coordinate system), with translational velocity U₀ in the inertial x direction, initial angle alpha_0, dimensionless angular velocity K = dotalpha_0c2U_0, and angular change Deltaalpha. The optional ramp argument is assumed to be given by the smooth ramp EldredgeRamp with a smoothness factor of 11 (larger values lead to sharper transitions on/off the ramp), but this can be replaced by another Eldredge ramp with a different value or a ColoniusRamp.\n\n\n\n\n\n","category":"type"},{"location":"manual/motions/#RigidBodyTools.RotationalOscillation","page":"Making bodies move","title":"RigidBodyTools.RotationalOscillation","text":"RotationalOscillation(ax,ay,Ω,α₀,α̇₀,Δα,ϕα)\n\nSet oscillatory rotational kinematics about an axis located at ax, ay (expressed relative to the body centroid, in a body-fixed coordinate system), of the form\n\nalpha(t) = alpha_0 + dotalpha_0 t + Deltaalpha sin(Omega t - phi_alpha)\n\n\n\n\n\nRotationalOscillation(Ω,Δα,ϕα)\n\nSet oscillatory rotational kinematics about the centroid of the form\n\nalpha(t) = Deltaalpha sin(Omega t - phi_alpha)\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.SwitchedKinematics","page":"Making bodies move","title":"RigidBodyTools.SwitchedKinematics","text":"SwitchedKinematics <: Kinematics\n\nModulates a given set of kinematics between simple on/off states. The velocity specified by the given kinematics is toggled on/off.\n\nFields\n\nt_on\ntime at which the kinematics should be turned on\nt_off\ntime at which the kinematics should be turned off\nkin\nkinematics to be followed in the on state\noff\n\n\n\n\n\n","category":"type"},{"location":"manual/motions/#Rigid-body-kinematics-convenience-functions","page":"Making bodies move","title":"Rigid body kinematics convenience functions","text":"","category":"section"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"complex_translational_position\ncomplex_translational_velocity\ncomplex_translational_acceleration\ntranslational_position\ntranslational_velocity\ntranslational_acceleration\nangular_position\nangular_velocity\nangular_acceleration","category":"page"},{"location":"manual/motions/#RigidBodyTools.complex_translational_position","page":"Making bodies move","title":"RigidBodyTools.complex_translational_position","text":"complex_translational_position(k::KinematicData;[inertial=true]) -> ComplexF64\n\nReturn the complex translational position (relative to the initial   position) of kinematic data k, expressed in inertial coordinates (if inertial=true,     the default) or in comoving coordinates if inertial=false.\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.complex_translational_velocity","page":"Making bodies move","title":"RigidBodyTools.complex_translational_velocity","text":"complex_translational_velocity(k::KinematicData;[inertial=true]) -> ComplexF64\n\nReturn the complex translational velocity of kinematic data k, relative to inertial reference frame, expressed in inertial coordinates (if inertial=true,   the default) or in comoving coordinates if inertial=false.\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.complex_translational_acceleration","page":"Making bodies move","title":"RigidBodyTools.complex_translational_acceleration","text":"complex_translational_acceleration(k::KinematicData;[inertial=true]) -> ComplexF64\n\nReturn the complex translational acceleration of kinematic data k, relative to inertial reference frame, expressed in inertial coordinates (if inertial=true,   the default) or in comoving coordinates if inertial=false.\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.translational_position","page":"Making bodies move","title":"RigidBodyTools.translational_position","text":"translational_position(k::KinematicData;[inertial=true]) -> Tuple\n\nReturn the translational position of kinematic data k (relative to the initial   position), expressed as a Tuple in inertial coordinates (if inertial=true,     the default) or in comoving coordinates if inertial=false.\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.translational_velocity","page":"Making bodies move","title":"RigidBodyTools.translational_velocity","text":"translational_velocity(k::KinematicData;[inertial=true]) -> Tuple\n\nReturn the translational velocity of kinematic data k, relative to inertial reference frame, expressed as a Tuple in inertial coordinates (if inertial=true,   the default) or in comoving coordinates if inertial=false.\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.translational_acceleration","page":"Making bodies move","title":"RigidBodyTools.translational_acceleration","text":"translational_acceleration(k::KinematicData;[inertial=true]) -> Tuple\n\nReturn the translational acceleration of kinematic data k, relative to inertial reference frame, expressed as a Tuple in inertial coordinates (if inertial=true,   the default) or in comoving coordinates if inertial=false.\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.angular_position","page":"Making bodies move","title":"RigidBodyTools.angular_position","text":"angular_position(k::KinematicData) -> Float64\n\nReturn the angular orientation of kinematic data k, relative to inital value, in the inertial reference frame.\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.angular_velocity","page":"Making bodies move","title":"RigidBodyTools.angular_velocity","text":"angular_velocity(k::KinematicData) -> Float64\n\nReturn the angular velocity of kinematic data k, relative to inertial reference frame.\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/#RigidBodyTools.angular_acceleration","page":"Making bodies move","title":"RigidBodyTools.angular_acceleration","text":"angular_acceleration(k::KinematicData) -> Float64\n\nReturn the angular acceleration of kinematic data k, relative to inertial reference frame.\n\n\n\n\n\n","category":"function"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"","category":"page"},{"location":"manual/motions/","page":"Making bodies move","title":"Making bodies move","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/utilities/#Surface-functions-and-other-utilities","page":"Surface functions and other utilities","title":"Surface functions and other utilities","text":"","category":"section"},{"location":"manual/utilities/","page":"Surface functions and other utilities","title":"Surface functions and other utilities","text":"DocTestSetup = quote\n  using RigidBodyTools\nend","category":"page"},{"location":"manual/utilities/","page":"Surface functions and other utilities","title":"Surface functions and other utilities","text":"centraldiff\nBase.diff(::Body)\nBase.diff(::BodyList)\ndlength\ndlengthmid\nBase.length(::Body)\nmidpoints(::Body)\nmidpoints(::BodyList)\nnormal\nnormalmid","category":"page"},{"location":"#RigidBodyTools.jl","page":"Home","title":"RigidBodyTools.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools for creating, moving, and discretizing rigid bodies","category":"page"},{"location":"","page":"Home","title":"Home","text":"The purpose of this package is to provide tools for rigid bodies with point-discretized surfaces. It includes methods for","category":"page"},{"location":"","page":"Home","title":"Home","text":"a library of surface shape definitions and associated point discretizations\ncalculation of geometric properties\nrigid-body motion and transformation of surface points\ncollections of multiple rigid bodies","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package works on Julia 1.0 and above and is registered in the general Julia registry. To install from the REPL, type e.g.,","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add RigidBodyTools","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, in any version, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using RigidBodyTools","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plots in this documentation are generated using Plots.jl. You might want to install that, too, to follow the examples.","category":"page"}]
}
