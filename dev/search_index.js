var documenterSearchIndex = {"docs":
[{"location":"manual/joints/#Joints-and-body-joint-systems","page":"Joints and body-joint systems","title":"Joints and body-joint systems","text":"For systems consisting of one or more rigid bodies, joints are used to specify the degrees of freedom permitted for the body. Even for a single rigid body, the body is assumed to be connected by a joint with the inertial coordinate system.\n\nIn three dimensions, there are several different classes of joint:\n\nRevoluteJoint, which rotates about an axis and has only one degree of freedom\nPrismaticJoint, which slides along one axis and has only one degree of freedom\nHelicalJoint, which rotates about and slides along one axis (two degrees of freedom)\nSphericalJoint, which rotates freely about one point (three degrees of freedom)\nFreeJoint, which can move in any manner (six degrees of freedom)\n\nHowever, in two spatial dimensions, there are only two\n\nRevoluteJoint (one degree of freedom: rotation)\nFreeJoint2d (three degrees of freedom: rotation, two translation)\n\nusing RigidBodyTools\nusing Plots\n\nA joint serves as a connection between two bodies; one of the bodies is the parent and the other is the child. It is also common for a body to be connected to the inertial coordinate system, in which case the inertial system is the parent and the body is the child. The user must specify the id of the parent body and the child body. The id of the inertial system is 0.\n\nBefore we discuss how a joint is specified, it is important to understand that a joint is basically just an intermediate MotionTransform from the parent body's system to the child body's system.\n\nThat is, to construct the transform from body P to body C, we would compose it as follows\n\n^C X_P = ^CX_J(C) ^J(C)X_J(P) ^J(P)X_P\n\nThe transform in the middle is the joint transform and is the only one of these that can vary in time. It maps from one coordinate system attached (rididly) to the parent body to another coordinate system attached (rigidly) to the child body.\n\nThe degrees of freedom of the joint constrain the behavior of this joint transform. Below, we show how joints are constructed and used.","category":"section"},{"location":"manual/joints/#Joint-construction-generalities","page":"Joints and body-joint systems","title":"Joint construction generalities","text":"The user must specify where the joint is located on each body, relative to the origin of the body's coordinate system, and what orientation the joint takes with respect to the body's coordinate system. These are specified with MotionTransforms, transforming from each body's coordinate system to the joint's coordinate system on that body. This transform is invariant – it never changes.\n\nAlso, the user must specify the behavior of each of the degrees of freedom of a joint, using the tools we discussed in the previous page.\n\nThe basic signature is\n\nJoint(joint_type,parent_body_id,Xp_to_jp,child_body_id,Xc_to_jc,doflist)\n\nHowever, there is a specialized signature if you simply wish to place a body in some stationary configuration X:\n\nJoint(X,body_id)\n\nand if there is only one body and it is stationary, then\n\nJoint(X)\n\nwill do.","category":"section"},{"location":"manual/joints/#Example","page":"Joints and body-joint systems","title":"Example","text":"Let's see a 2d example. Suppose we have two bodies, 1 and 2. Body 1 is to be connected to the inertial coordinate system, and prescribed with motion that causes it to oscillate rotationally (pitch) about a point located at (-10) and in the body's coordinate system, and this pitch axis can oscillate up and down (heave).\n\nBody 2 is to be connected by a hinge to body 1, and this hinge's angle will also oscillate. We will set the hinge to be located at (1020) on body 1 and (-1020) on body 2.","category":"section"},{"location":"manual/joints/#Joint-from-inertial-system-to-body-1","page":"Joints and body-joint systems","title":"Joint from inertial system to body 1","text":"First, let's construct the joint from the inertial system to body 1. This should be a FreeJoint2d, since motion is prescribed in two of the three degrees of freedom (as well as the third one, with zero velocity). We can assume that the joint is attached to the origin of the parent (the inertial system). On the child (body 1), the joint is to be at [-1,0].\n\npid = 0\nXp_to_jp = MotionTransform([0,0],0)\ncid = 1\nXc_to_jc = MotionTransform([-1,0],0)\n\nFor the rotational and the y degrees of freedom, we need oscillatory motion. For the rotational motion, let's set the amplitude to pi4 and the angular frequency to Omega = 2pi, but set the phase and mean velocity both to zero.\n\nAr = π/4\nΩ = 2π\nϕr = 0.0\nvel = 0.0\nkr = OscillatoryDOF(Ar,Ω,ϕr,vel)\n\nFor the plunging, we will set an amplitude of 1 and a phase lag of pi2, but keep the same frequency as the pitching.\n\nAy = 1\nϕy = -π/2\nky = OscillatoryDOF(Ay,Ω,ϕy,vel)\n\nThe x degree of freedom is simply constant velocity, set to 0, to ensure it does not move in the x direction.\n\nkx = ConstantVelocityDOF(0)\n\nWe put these together into a vector, to pass along to the joint constructor. The ordering of these in the vector is important. It must be [rotational, x, y].\n\ndofs = [kr,kx,ky];\nnothing #hide\n\nNow set the joint\n\njoint1 = Joint(FreeJoint2d,pid,Xp_to_jp,cid,Xc_to_jc,dofs)\n\nNote that this joint has three constrained degrees of freedom, no exogenous degrees of freedom, and no unconstrained degrees of freedom. In a later example, we will change this.","category":"section"},{"location":"manual/joints/#Joint-from-body-1-to-body-2","page":"Joints and body-joint systems","title":"Joint from body 1 to body 2","text":"This joint is a RevoluteJoint. First set the joint locations on each body.\n\npid = 1\nXp_to_jp = MotionTransform([1.02,0],0)\ncid = 2\nXc_to_jc = MotionTransform([-1.02,0],0)\n\nNow set its single degree of freedom (rotation) to have oscillatory kinematics. We will set its amplitude the same as before, but give it a phase lag\n\nAr = π/4\nΩ = 2π\nϕr = -π/4\nkr = OscillatoryDOF(Ar,Ω,ϕr,vel)\n\nPut it in a one-element vector.\n\ndofs = [kr];\nnothing #hide\n\nand construct the joint\n\njoint2 = Joint(RevoluteJoint,pid,Xp_to_jp,cid,Xc_to_jc,dofs)\n\nGroup the two joints together into a vector. It doesn't matter what order this vector is in, since the connectivity will be figured out any way it is ordered, but it numbers the joints by the order they are provided here.\n\njoints = [joint1,joint2];\nnothing #hide","category":"section"},{"location":"manual/joints/#Assembling-the-joints-and-bodies","page":"Joints and body-joint systems","title":"Assembling the joints and bodies","text":"The joints and bodies comprise an overall RigidBodyMotion system. When this system is constructed, all of the connectivities are determined (or missing connectivities are revealed). The construction requires that we have set up the bodies themselves, so let's do that first. We will make both body 1 and body 2 an ellipse of aspect ratio 5. Note that ordering of bodies matters here, because the first in the list is interpreted as body 1, etc.\n\nb1 = Ellipse(1.0,0.2,0.02)\nb2 = Ellipse(1.0,0.2,0.02)\nbodies = BodyList([b1,b2])\n\nNow we can construct the system\n\nls = RigidBodyMotion(joints,bodies)\n\nBefore we proceed, it is useful to demonstrate some of the tools we have to probe the connectivity of the system. For example, to find the parent joint of body 1, we use\n\nparent_joint_of_body(1,ls)\n\nThis returns 1, since we have connected body 1 to joint 1. How about the child joint of body 1? We expect it to be 2. Since there might be more than one child, this returns a vector:\n\nchild_joints_of_body(1,ls)\n\nWe can also check the body connectivity of joints. This can be very useful for more complicated systems in which the joint numbering is less clear. The parent body of joint 1\n\nparent_body_of_joint(1,ls)\n\nThis returns 0 since we have connected joint 1 to the inertial system. The child body of joint 2:\n\nchild_body_of_joint(2,ls)","category":"section"},{"location":"manual/joints/#The-system-state-vector","page":"Joints and body-joint systems","title":"The system state vector","text":"A key concept in advancing, plotting, and doing further analysis of this system of joints and bodies is the state vector, x. This state vector has entries for the position of every degree of freedom of all of the joints. It also may have further entries for other quantities that need to be advanced, but for this example, there are no other entries.\n\nThere are two functions that are useful for constructing the state vector. The first is zero_motion_state, which simply creates a vector of zeros of the correct size.\n\nzero_motion_state(bodies,ls)\n\nThe second is init_motion_state, which fills in initial position values for any degrees of freedom that have been prescribed.\n\nx = init_motion_state(bodies,ls)\n\nNote that neither of these functions has any mutating effect on the arguments (bodies and ls).\n\nAlso, it is always possible for the user to modify the entries in the state vector after this function is called. In general, it would be difficult to determine which entry is which in this state vector, so we can use a special function for this. For example, to get access to just the part of the state vector for the positions of joint 1,\n\njid = 1\nx1 = position_vector(x,ls,jid)\n\nThis is a view on the overall state vector. This, if you decide to change an entry of x1, this, in turn, would change the correct entry in x.\n\nWe can use the system state vector to put the bodies in their proper places, using the joint positions in x.\n\nupdate_body!(bodies,x,ls)\n\nLet's plot this just to check\n\nplot(bodies,xlims=(-4,4),ylims=(-4,4))","category":"section"},{"location":"manual/joints/#Advancing-the-state-vector","page":"Joints and body-joint systems","title":"Advancing the state vector","text":"Once the initial state vector is constructed, then the system can be advanced in time. In this example, there are no exogenous or unconstrained degrees of freedom that require extra input, so the system is closed as it is. To advance the system, we need to solve the system of equations fracmathrmdxmathrmdt = f(xt)\n\nThe function f(xt) describing the rate of change of x is given by the function motion_rhs!. This function mutates its first argument, the rate-of-change vector dxdt, which can then be used to update the state. The system and bodies are passed in as a tuple, followed by time.\n\nUsing a simple forward Euler method, the state vector can be advanced as follows\n\nt0, x0 = 0.0, init_motion_state(bodies,ls)\ndxdt = zero(x0)\nx = copy(x0)\ndt, tmax = 0.01, 4.0\nfor t in t0:dt:t0+tmax\n  motion_rhs!(dxdt,x,(ls,bodies),t)\n  global x += dxdt*dt\nend\n\nNow that we know how to advance the state vector, let's create a macro that can be used to make a movie of the evolving system.\n\nmacro animate_motion(b,m,dt,tmax,xlim,ylim)\n    return esc(quote\n            bc = deepcopy($b)\n            t0, x0 = 0.0, init_motion_state(bc,$m)\n            dxdt = zero(x0)\n            x = copy(x0)\n\n            @gif for t in t0:$dt:t0+$tmax\n                motion_rhs!(dxdt,x,($m,bc),t)\n                global x += dxdt*$dt\n                update_body!(bc,x,$m)\n                plot(bc,xlims=$xlim,ylims=$ylim)\n            end every 5\n        end)\nend\n\nLet's use it here\n\n@animate_motion bodies ls 0.01 4 (-4,4) (-4,4)","category":"section"},{"location":"manual/joints/#Joint-functions","page":"Joints and body-joint systems","title":"Joint functions","text":"","category":"section"},{"location":"manual/joints/#System-and-state-functions","page":"Joints and body-joint systems","title":"System and state functions","text":"","category":"section"},{"location":"manual/joints/#Joint-types","page":"Joints and body-joint systems","title":"Joint types","text":"\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"manual/joints/#RigidBodyTools.Joint","page":"Joints and body-joint systems","title":"RigidBodyTools.Joint","text":"Joint(jtype::AbstractJointType,parent_id,Xp_to_j::MotionTransform,child_id,Xch_to_j::MotionTransform,\n        dofs::Vector{AbstractDOFKinematics};[params=Dict()])\n\nConstruct a joint of type jtype, connecting parent body of id parent_id to child body of id child_id. The placement of the joint on the bodies is given by Xp_to_j and Xch_to_j, the transforms from the parent and child coordinate systems to the joint system, respectively. Each of the degrees of freedom for the joint is specified with dofs, a vector of AbstractDOFKinematics. Any parameters required by the joint can be passed along in the optional params dictionary.\n\n\n\n\n\nJoint(X::MotionTransform,bid::Int)\n\nConstruct a joint that simply places the body with ID bid rigidly in the configuration given by X.\n\n\n\n\n\nJoint(X::MotionTransform)\n\nFor a problem with a single body, construct a joint that simply places the body rigidly in the configuration given by X.\n\n\n\n\n\n","category":"type"},{"location":"manual/joints/#RigidBodyTools.zero_joint","page":"Joints and body-joint systems","title":"RigidBodyTools.zero_joint","text":"zero_joint(joint::Joint[;dimfcn=position_and_vel_dimension])\n\nCreate a vector of zeros for different aspects of the joint state, based on the argument dimfcn. By default, it uses position_and_vel_dimension and creates a zero vector sized according to the the position of the joint and the parts of the joint velocity that must be advanced (from acceleration). Alternatively, one can use position_dimension, constrained_dimension, unconstrained_dimension, or exogenous_dimension.\n\n\n\n\n\nzero_joint(ls::RigidBodyMotion[;dimfcn=position_and_vel_dimension])\n\nCreate a vector of zeros for some aspect of the state of the linked system(s) ls, based on the argument dimfcn. By default, it uses position_and_vel_dimension and creates a zero vector sized according to the state of the joint. Alternatively, one can use position_dimension, constrained_dimension, unconstrained_dimension, or exogenous_dimension.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.init_joint","page":"Joints and body-joint systems","title":"RigidBodyTools.init_joint","text":"init_joint(joint::Joint[;tinit=0.0])\n\nCreate an initial state vector for a joint. It initializes the joint's constrained degrees of freedom with their kinematics, evaluated at time tinit (equal to zero, by default). Other degrees of freedom (exogenous, unconstrained) are initialized to zero, so they can be set manually.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.RigidBodyMotion","page":"Joints and body-joint systems","title":"RigidBodyTools.RigidBodyMotion","text":"RigidBodyMotion\n\nType containing the connectivities and motions of rigid bodies, linked to the inertial system and possibly to each other, via joints. The basic constructor is RigidBodyMotion(joints::Vector{Joint},nbody::Int), in which joints contains a vector of joints of Joint type, each specifying the connection between a parent and a child body. (The parent may be the inertial coordinate system.)\n\n\n\n\n\n","category":"type"},{"location":"manual/joints/#RigidBodyTools.zero_motion_state","page":"Joints and body-joint systems","title":"RigidBodyTools.zero_motion_state","text":"zero_motion_state(bl::BodyList,ls::RigidBodyMotion)\n\nCreate a vector of zeros for the state of the linked system(s) ls.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.init_motion_state","page":"Joints and body-joint systems","title":"RigidBodyTools.init_motion_state","text":"init_motion_state(bl::BodyList,ls::RigidBodyMotion[;tinit = 0.0])\n\nInitialize the global linked system state vector, using the prescribed motions for constrained degrees of freedom to initialize the position components (evaluated at tinit, which by default is 0). The other degrees of freedom are initialized to zero, and can be set manually.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#Base.view-Tuple{AbstractVector, RigidBodyMotion, Int64}","page":"Joints and body-joint systems","title":"Base.view","text":"view(q::AbstractVector,ls::RigidBodyMotion,jid::Int[;dimfcn=position_dimension]) -> SubArray\n\nProvide a view of the range of values in vector q corresponding to the position of the joint with index jid in a RigidBodyMotion ls. The optional argument dimfcn can be set to position_dimension, constrained_dimension, unconstrained_dimension, or exogenous_dimension.\n\n\n\n\n\n","category":"method"},{"location":"manual/joints/#RigidBodyTools.position_vector","page":"Joints and body-joint systems","title":"RigidBodyTools.position_vector","text":"position_vector(x::AbstractVector,ls::RigidBodyMotion)\n\nReturns a view of the global state vector for a linked system containing only the position.\n\n\n\n\n\nposition_vector(x::AbstractVector,ls::RigidBodyMotion,jid::Int)\n\nReturns a view of the global state vector for a linked system containing only the position of joint jid.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.velocity_vector","page":"Joints and body-joint systems","title":"RigidBodyTools.velocity_vector","text":"velocity_vector(x::AbstractVector,ls::RigidBodyMotion)\n\nReturns a view of the global state vector for a linked system containing only the velocity.\n\n\n\n\n\nvelocity_vector(x::AbstractVector,ls::RigidBodyMotion,jid::Int)\n\nReturns a view of the global state vector for a linked system containing only the velocity of joint jid.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.deformation_vector","page":"Joints and body-joint systems","title":"RigidBodyTools.deformation_vector","text":"deformation_vector(x::AbstractVector,ls::RigidBodyMotion,bid::Int)\n\nReturns a view of the global state vector for a linked system containing only the body surface positions of the body with id bid.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.exogenous_position_vector","page":"Joints and body-joint systems","title":"RigidBodyTools.exogenous_position_vector","text":"exogenous_position_vector(x::AbstractVector,ls::RigidBodyMotion,jid::Int)\n\nReturns a view of the exogenous dof position(s), if any, of joint jid in the global state vector x.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.exogenous_velocity_vector","page":"Joints and body-joint systems","title":"RigidBodyTools.exogenous_velocity_vector","text":"exogenous_velocity_vector(x::AbstractVector,ls::RigidBodyMotion,jid::Int)\n\nReturns a view of the exogenous dof position(s), if any, of joint jid in the global state vector x.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.unconstrained_position_vector","page":"Joints and body-joint systems","title":"RigidBodyTools.unconstrained_position_vector","text":"unconstrained_position_vector(x::AbstractVector,ls::RigidBodyMotion,jid::Int)\n\nReturns a view of the unconstrained dof position(s), if any, of joint jid in the global state vector x.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.unconstrained_velocity_vector","page":"Joints and body-joint systems","title":"RigidBodyTools.unconstrained_velocity_vector","text":"unconstrained_velocity_vector(x::AbstractVector,ls::RigidBodyMotion,jid::Int)\n\nReturns a view of the unconstrained dof position(s), if any, of joint jid in the global state vector x.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.body_transforms","page":"Joints and body-joint systems","title":"RigidBodyTools.body_transforms","text":"body_transforms(x::AbstractVector,ls::RigidBodyMotion) -> MotionTransformList\n\nParse the overall state vector x into the individual joints and construct the inertial system-to-body transforms for every body. Return these transforms in a MotionTransformList.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.motion_transform_from_A_to_B","page":"Joints and body-joint systems","title":"RigidBodyTools.motion_transform_from_A_to_B","text":"motion_transform_from_A_to_B(tl::MotionTransformList,bodyidA::Int,bodyidB::Int) -> MotionTransform\n\nReturns a motion transform mapping from the coordinate system of body bodyidA to body bodyidB. Either of these bodies might be 0.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.force_transform_from_A_to_B","page":"Joints and body-joint systems","title":"RigidBodyTools.force_transform_from_A_to_B","text":"force_transform_from_A_to_B(tl::MotionTransformList,bodyidA::Int,bodyidB::Int) -> ForceTransform\n\nReturns a force transform mapping from the coordinate system of body bodyidA to body bodyidB. Either of these bodies might be 0.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.body_velocities","page":"Joints and body-joint systems","title":"RigidBodyTools.body_velocities","text":"body_velocities(x::AbstractVector,t::Real,ls::RigidBodyMotion) -> PluckerMotionList\n\nCompute the velocities of bodies for the rigid body system ls, expressing each in its own coordinate system. To carry this out, the function evaluates velocities of dofs with prescribed kinematics at time t and and obtains the remaining free dofs (exogenous and unconstrained) from the state vector x.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.motion_rhs!","page":"Joints and body-joint systems","title":"RigidBodyTools.motion_rhs!","text":"motion_rhs!(dxdt::AbstractVector,x::AbstractVector,p::Tuple{RigidBodyMotion,BodyList},t::Real)\n\nSets the right-hand side vector dxdt (mutating) for linked system ls of bodies bl, using the current state vector x, the current time t.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.zero_exogenous","page":"Joints and body-joint systems","title":"RigidBodyTools.zero_exogenous","text":"zero_exogenous(ls::RigidBodyMotion)\n\nGenerate a zero vector of exogenous acclerations for system ls\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.update_exogenous!","page":"Joints and body-joint systems","title":"RigidBodyTools.update_exogenous!","text":"update_exogenous!(ls::RigidBodyMotion,a_edof::AbstractVector)\n\nMutates the exogenous buffer of ls with the supplied vector of exogenous accelerations a_edof. This function is useful for supplying time-varying exogenous values to the integrator from an outer loop.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.maxvelocity","page":"Joints and body-joint systems","title":"RigidBodyTools.maxvelocity","text":"maxvelocity(b::Union{Body,BodyList},x::AbstractVector,m::RigidBodyMotion[,tmax=10,dt=0.05])\n\nSearch through the given motion state vector x and motion m applied to body b and return (umax,i,t,bid), the maximum velocity magnitude, the global index of the body point where it occurs, the time at which it occurs, and the body on which it occurs.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.ismoving-Tuple{RigidBodyMotion}","page":"Joints and body-joint systems","title":"RigidBodyTools.ismoving","text":"ismoving(m::RigidBodyMotion)\n\nChecks if any joint in m is in motion\n\n\n\n\n\n","category":"method"},{"location":"manual/joints/#RigidBodyTools.is_system_in_relative_motion","page":"Joints and body-joint systems","title":"RigidBodyTools.is_system_in_relative_motion","text":"is_system_in_relative_motion(lsid::Int,ls::RigidBodyMotion) -> Bool\n\nReturns true if the linked system with ID lsid is in relative motion, i.e., if one or more of the joints (not connected to the inertial system) returns true for the function ismoving(joint).\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.rebase_from_inertial_to_reference","page":"Joints and body-joint systems","title":"RigidBodyTools.rebase_from_inertial_to_reference","text":"rebase_from_inertial_to_reference(Xi_to_A::MotionTransform,x::AbstractVector,m::RigidBodyMotion,reference_body::Int)\n\nIf Xi_to_A represents a motion transform from the inertial coordinates to some other coordinates A, such as that of a body, then this function returns a motion transform from the reference body coordinates to coordinates A. It uses the current joint state vector x to construct the transform list of the system m.\n\n\n\n\n\n","category":"function"},{"location":"manual/joints/#RigidBodyTools.RevoluteJoint","page":"Joints and body-joint systems","title":"RigidBodyTools.RevoluteJoint","text":"RevoluteJoint <: AbstractJointType\n\nA 2d or 3d joint with one rotational (about z axis) degree of freedom.\n\n\n\n\n\n","category":"type"},{"location":"manual/joints/#RigidBodyTools.PrismaticJoint","page":"Joints and body-joint systems","title":"RigidBodyTools.PrismaticJoint","text":"PrismaticJoint <: AbstractJointType\n\nA 3d joint with one translational (along z axis) degree of freedom.\n\n\n\n\n\n","category":"type"},{"location":"manual/joints/#RigidBodyTools.HelicalJoint","page":"Joints and body-joint systems","title":"RigidBodyTools.HelicalJoint","text":"HelicalJoint <: AbstractJointType\n\nA 3d joint with one rotational (angle about z axis) degree of freedom, and coupled translational motion along the z axis based on pitch.\n\n\n\n\n\n","category":"type"},{"location":"manual/joints/#RigidBodyTools.SphericalJoint","page":"Joints and body-joint systems","title":"RigidBodyTools.SphericalJoint","text":"SphericalJoint <: AbstractJointType\n\nA 3d joint with three rotational degrees of freedom. It uses a quaternion to define its orientation, so it has four position coordinates.\n\n\n\n\n\n","category":"type"},{"location":"manual/joints/#RigidBodyTools.FreeJoint","page":"Joints and body-joint systems","title":"RigidBodyTools.FreeJoint","text":"FreeJoint <: AbstractJointType\n\nA 3d joint with all six degrees of freedom. It uses a quaternion to define its orientation, so it has seven position coordinates.\n\n\n\n\n\n","category":"type"},{"location":"manual/joints/#RigidBodyTools.FreeJoint2d","page":"Joints and body-joint systems","title":"RigidBodyTools.FreeJoint2d","text":"FreeJoint2d <: AbstractJointType\n\nA 2d joint with three degrees of freedom (angle, x, y).\n\n\n\n\n\n","category":"type"},{"location":"manual/transforms/#Plucker-vectors-and-coordinate-transforms","page":"Plucker vectors and coordinate transforms","title":"Plucker vectors and coordinate transforms","text":"Here we discuss the use of Plücker vectors and their transforms for describing rigid-body motion and force. Plücker vectors succinctly describe both the angular (rotational) and linear (translational) part of motion, and the angular (moment) and linear (force) part of force. In three dimensions, a Plücker vector is 6-dimensional, e.g., Plücker velocity and force vectors are\n\nv = beginbmatrix Omega_x  Omega_y  Omega_z  U_x  U_y  U_z endbmatrix qquad\nf = beginbmatrix M_x  M_y  M_z  F_x  F_y  F_z endbmatrix\n\nIn two dimensions, there is only one angular component and two linear components, e.g.,\n\nv = beginbmatrix Omega_z  U_x  U_y endbmatrix qquad f = beginbmatrix M_z  F_x  F_y endbmatrix\n\nWe need to be able to transform these vectors from one coordinate system to another. This requires rotating their components and shifting their center from one origin to another. For example, a translational velocity based at system B will be different from the translational velocity at system A because of the rotational velocity, Omega times ^Br_A, where ^Br_A is the vector from the origin of A to the origin of B.\n\nSimilarly, the moment about B will be different from the moment about A due to the moment arm ^Br_A times F.\n\nusing RigidBodyTools\nusing LinearAlgebra\nusing Plots","category":"section"},{"location":"manual/transforms/#Plücker-vectors","page":"Plucker vectors and coordinate transforms","title":"Plücker vectors","text":"A Plücker vector is easily created by simply supplying a vector of its components\n\nv = PluckerMotion([1.0,2.0,3.0])\n\nThis created a 2d motion vector, with angular velocity 1.0 and linear velocity (2.0,3.0). One can also supply the angular and linear parts separately, using keywords. If one of these keywords is omitted, it defaults to zero for that part. Note that we also need to write this as PluckerMotion{2} to specify the physical dimensionality. For a 3d motion vector, one would write PluckerMotion{3} here.\n\nv2 = PluckerMotion{2}(angular=1.0,linear=[2.0,3.0])\nv2 == v\n\nWe can also pick off the angular and linear parts\n\nangular_only(v)\n\nand\n\nlinear_only(v)\n\nForce vectors are similar\n\nf = PluckerForce([-1.0,-3.5,2.25])\n\nThe vectors of the same type can be added and subtracted\n\nv3 = v + v2\n\nWe can also take a scalar product of force and motion vectors\n\ndot(f,v)","category":"section"},{"location":"manual/transforms/#Transforms","page":"Plucker vectors and coordinate transforms","title":"Transforms","text":"Transforms are constructed by describing the relationship between the two coordinate systems. Consider the example in the figure below.\n\n(Image: CoordinateSystems.svg)\n\nTo develop the 2d transform from A to B, we supply the position r and the rotation angle theta. For example, if B is shifted by [1,1] and rotated by angle pi6 counterclockwise about A, then we construct the transform as\n\nXm = MotionTransform([1,1],π/6)\n\nNote that it uses the angle of rotation, pi6, to create a rotation matrix operator.\n\nA 2d force transform would be constructed by\n\nXf = ForceTransform([1,1],π/6)\n\nFor 3d transforms, we need to supply the rotation operator itself (as well as the 3d translation vector). Often, this rotation is done by rotating about a certain axis by a certain angle. We do this with the rotation_about_axis function. For example, to rotate by pi4 about an axis parallel to the vector 111, then we use\n\nR = rotation_about_axis(π/4,[1,1,1])\n\nand then to translate this rotated system by -1-2-3,\n\nXm = MotionTransform([-1,-2,-3],R)\n\nand similarly for a force transform.\n\nWe can also compute the inverses of these transforms, to transform back from B to A\n\ninv(Xm)\n\nTransforms of the same type (motion or force) can be composed via multiplication to transform from, e.g., A to B to C.\n\nXm1 = MotionTransform([1.5,1.5],π/6)\nXm2 = MotionTransform([-1,1],π/3)\nXm2*Xm1","category":"section"},{"location":"manual/transforms/#Transforming-bodies","page":"Plucker vectors and coordinate transforms","title":"Transforming bodies","text":"We can use motion transforms, in particular, to place bodies. We simply apply the transform as a function, and it transforms the body's coordinates. For example, transform Xm1 above shifts the body to [1.5,1.5] and rotates it counterclockwise by π/6:\n\nb = Ellipse(1.0,0.2,0.02)\nplot(b,xlims=(-3,3),ylims=(-3,3),fillcolor=:gray)\nplot!(Xm1(b),xlims=(-3,3),ylims=(-3,3))\n\nIn the example above, we did not affect the original body by applying the transform as a function. Rather, we created a copy of the body.\n\nIf, instead, you wish to transform the body in place, use update_body!\n\nupdate_body!(b,Xm1)\n\nOne important note: a body stores a set of coordinates in its own intrinsic coordinate system, and when a transform is applied to the body, it always acts on these coordinates. This means that the transform's application on the body cannot be carried out as a composite of operations, e.g. T2(T1(b)) is not possible. Insteady, in the application on the body, the transform is always interpreted such that system A is the inertial coordinate system and B is the body system. Of course, the transform itself can always be constructed from composite transforms.\n\nSometimes we need information about the normals in the body system. For these, we can use normalmid with the flag axes=:body:\n\nnx, ny = normalmid(b,axes=:body)\n\nFinally, if you wish to transform the body's own coordinate system, rather than use the transform to simply place the body in the inertial system, then use transform_body!. This transforms the intrinsic coordinates of the body.\n\ntransform_body!(b,Xm1)","category":"section"},{"location":"manual/transforms/#Transforming-Plücker-vectors","page":"Plucker vectors and coordinate transforms","title":"Transforming Plücker vectors","text":"Transforms can be applied to Plücker vectors to transform their components between systems. Let's consider a 2d example in which the motion based at system A is purely a rotation with angular velocity Omega = 1, and we wish to transform this to system B, translated by 20 from A, but with axes aligned with B. We expect that the velocity based at B should have the same angular velocity, but also should have translational velocity equal to 02 due to the angular motion.\n\nFirst we construct the motion vector at A\n\nΩ = 1.0\nvA = PluckerMotion(Ω,[0,0])\n\nNow construct the transform from A to B:\n\nXA_to_B = MotionTransform([2,0],0)\n\nNow apply the transform to get the velocity at B:\n\nvB = XA_to_B*vA\n\nwhich gives the expected result. Now let's transform back, using the inverse, and check that we get back to vA\n\ninv(XA_to_B)*vB","category":"section"},{"location":"manual/transforms/#Transform-functions","page":"Plucker vectors and coordinate transforms","title":"Transform functions","text":"\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"manual/transforms/#RigidBodyTools.PluckerMotion","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.PluckerMotion","text":"PluckerMotion(data::AbstractVector)\n\nCreates an instance of a Plucker motion vector,\n\nv = beginbmatrix Omega  U endbmatrix\n\nusing the vector in data. If data is of length 6, then it creates a 3d motion vector, and the first 3 entries are assumed to comprise the rotational component \\Omega and the last 3 entries the translational component U. If data is of length 3, then it creates a 2d motion vector, assuming that the first entry in data represents the rotational component and the second and third entries the x and y translational components.\n\n\n\n\n\n","category":"type"},{"location":"manual/transforms/#RigidBodyTools.PluckerForce","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.PluckerForce","text":"PluckerForce(data::AbstractVector)\n\nCreates an instance of a Plucker force vector,\n\nf = beginbmatrix M  F endbmatrix\n\nusing the vector in data. If data is of length 6, then it creates a 3d force vector, and the first 3 entries are assumed to comprise the moment component M and the last 3 entries the force component F. If data is of length 3, then it creates a 2d force vector, assuming that the first entry in data represents the moment component and the second and third entries the x and y force components.\n\n\n\n\n\n","category":"type"},{"location":"manual/transforms/#RigidBodyTools.angular_only","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.angular_only","text":"angular_only(v::AbstractPluckerVector)\n\nReturns a Plucker vector with only the angular part of the motion or force vector v available for subsequent operations. Note that no copy of the original data in v is made. Rather, this simply provides a lazy reference to the angular data in v.\n\n\n\n\n\n","category":"function"},{"location":"manual/transforms/#RigidBodyTools.linear_only","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.linear_only","text":"linear_only(v::AbstractPluckerVector)\n\nReturns a Plucker vector with only the linear part of the motion or force vector v available for subsequent operations. Note that no copy of the original data in v is made. Rather, this simply provides a lazy reference to the linear data in v.\n\n\n\n\n\n","category":"function"},{"location":"manual/transforms/#LinearAlgebra.dot-Tuple{RigidBodyTools.AbstractPluckerForceVector, RigidBodyTools.AbstractPluckerMotionVector}","page":"Plucker vectors and coordinate transforms","title":"LinearAlgebra.dot","text":"dot(f::AbstractPluckerForceVector,v::AbstractPluckerMotionVector) -> Real\n\nCalculate the scalar product between force f and motion v. The commutation of this is also possible, dot(v,f).\n\n\n\n\n\n","category":"method"},{"location":"manual/transforms/#RigidBodyTools.MotionTransform","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.MotionTransform","text":"(T::MotionTransform)(b::Body) -> Body\n\nTransforms a body b using the given MotionTransform, creating a copy of this body with the new configuration. In using this transform T (which defines a transform from system A to system B), A is interpreted as an inertial coordinate system and B as the body system. Thus, the position vector in T is interpreted as the relative position of the body in inertial coordinates and the inverse of the rotation operator is applied to transform body-fixed coordinates to the inertial frame.\n\n\n\n\n\nMotionTransform(xA_to_B::SVector,RA_to_B::SMatrix) -> MotionTransform\n\nComputes the Plucker transform matrix for motion vectors, transforming from system A to system B. The input xA_to_B is the Euclidean vector from the origin of A to the origin of B, expressed in A coordinates, and RA_to_B is the rotation matrix transforming coordinates in system A to those in system B. The resulting matrix has the form\n\n^B T^(m)_A = beginbmatrix R  0  0  R endbmatrix beginbmatrix 1  0  -x^times  1 endbmatrix\n\nOne can also provide xA_to_B as a standard vector and RA_to_B as a standard 3 x 3 matrix.\n\nIf xA_to_B has length 3, then a three-dimensional transform (a 6 x 6 Plucker transform) is created. If xA_to_B has length 2, then a two-dimensional transform (3 x 3 Plucker transform) is returned.\n\n\n\n\n\nMotionTransform(xA_to_B,θ::Real) -> MotionTransform\n\nComputes the 3 x 3 2D Plucker transform matrix for motion vectors, transforming from system A to system B. The input xA_to_B is the 2-d Euclidean vector from the origin of A to the origin of B, expressed in A coordinates, and θ is the angle of system B relative to system A. xA_to_B can be in the form of a static vector, a vector, or a tuple.\n\n\n\n\n\nMotionTransform(T::RigidTransform) -> MotionTransform\n\nComputes the 3 x 3 2D Plucker transform matrix for motion vectors, transforming from system A to system B, from the rigid transform T.\n\n\n\n\n\n","category":"type"},{"location":"manual/transforms/#RigidBodyTools.ForceTransform","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.ForceTransform","text":"ForceTransform(xA_to_B::SVector,RA_to_B::SMatrix) -> ForceTransform\n\nComputes the 6 x 6 Plucker transform matrix for force vectors, transforming from system A to system B. The input xA_to_B is the Euclidean vector from the origin of A to the origin of B, expressed in A coordinates, and RA_to_B is the rotation matrix transforming coordinates in system A to those in system B. The resulting matrix has the form\n\n^B T^(f)_A = beginbmatrix R  0  0  R endbmatrix beginbmatrix 1  -x^times  0  1 endbmatrix\n\n\n\n\n\nForceTransform(xA_to_B,θ::Real) -> ForceTransform\n\nComputes the 3 x 3 2D Plucker transform matrix for force vectors, transforming from system A to system B. The input xA_to_B is the 2-d Euclidean vector from the origin of A to the origin of B, expressed in A coordinates, and θ is the angle of system B relative to system A. xA_to_B can be in the form of a static vector, a vector, or a tuple.\n\n\n\n\n\nForceTransform(T::RigidTransform) -> ForceTransform\n\nComputes the 3 x 3 2D Plucker transform matrix for force vectors, transforming from system A to system B, from the rigid transform T.\n\n\n\n\n\n","category":"type"},{"location":"manual/transforms/#Base.inv-Tuple{AbstractTransformOperator}","page":"Plucker vectors and coordinate transforms","title":"Base.inv","text":"inv(M)\n\nMatrix inverse. Computes matrix N such that M * N = I, where I is the identity matrix. Computed by solving the left-division N = M \\ I.\n\nExamples\n\njulia> M = [2 5; 1 3]\n2×2 Matrix{Int64}:\n 2  5\n 1  3\n\njulia> N = inv(M)\n2×2 Matrix{Float64}:\n  3.0  -5.0\n -1.0   2.0\n\njulia> M*N == N*M == Matrix(I, 2, 2)\ntrue\n\n\n\n\n\ninv(X::AbstractTransformOperator) -> AbstractTransformOperator\n\nReturn the inverse of the motion or force transform X.\n\n\n\n\n\n","category":"method"},{"location":"manual/transforms/#Base.transpose-Tuple{AbstractTransformOperator}","page":"Plucker vectors and coordinate transforms","title":"Base.transpose","text":"transpose(X::MotionTransform) -> ForceTransform\ntranspose(X::ForceTransform) -> MotionTransform\n\nFor a motion transform X mapping from system A to B, returns the force transform mapping from B to A. Alternatively, if X is a force transform, it returns the motion transform.\n\n\n\n\n\n","category":"method"},{"location":"manual/transforms/#RigidBodyTools.rotation_transform","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.rotation_transform","text":"rotation_transform(T::AbstractTransformOperator) -> AbstractTransformOperator\n\nReturns a transform operator consisting of only the rotational part of T.\n\n\n\n\n\n","category":"function"},{"location":"manual/transforms/#RigidBodyTools.translation_transform","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.translation_transform","text":"translation_transform(T::AbstractTransformOperator) -> AbstractTransformOperator\n\nReturns a transform operator consisting of only the translational part of T.\n\n\n\n\n\n","category":"function"},{"location":"manual/transforms/#RigidBodyTools.update_body!","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.update_body!","text":"update_body!(b::Body,T::MotionTransform)\n\nTransforms a body (in-place) using the given MotionTransform. In using this transform T (which defines a transform from system A to system B), A is interpreted as an inertial coordinate system and B as the body system. Thus, the position vector in T is interpreted as the relative position of the body in inertial coordinates and the inverse of the rotation operator is applied to transform body-fixed coordinates to the inertial frame.\n\n\n\n\n\nupdate_body!(bl::BodyList,tl::MotionTransformList) -> BodyList\n\nCarry out in-place transformations of each body in bl with the corresponding transformation in tl.\n\n\n\n\n\nupdate_body!(bl::Union{Body,BodyList},x::AbstractVector,m::RigidBodyMotion)\n\nUpdate body/bodies in bl with the rigid-body motion m and state vector x.\n\n\n\n\n\n","category":"function"},{"location":"manual/transforms/#RigidBodyTools.transform_body!","page":"Plucker vectors and coordinate transforms","title":"RigidBodyTools.transform_body!","text":"transform_body!(b::Body,T::MotionTransform)\n\nTransforms a body's own coordinate system (in-place) using the given MotionTransform. This function differs from update_body! because it changes the coordinates of the body in its own coordinate system, whereas the latter function only changes the inertial coordinates of the body. T is interpreted as a transform from the new system to the old system.\n\n\n\n\n\ntransform_body!(bl::BodyList,tl::MotionTransformList) -> BodyList\n\nCarry out in-place transformations of body coordinate systems for each body in bl with the corresponding transformation in tl.\n\n\n\n\n\nupdate_body!(bl::Union{Body,BodyList},x::AbstractVector,m::RigidBodyMotion)\n\nTransform body/bodies in bl with the rigid-body motion m and state vector x.\n\n\n\n\n\n","category":"function"},{"location":"manual/bodylists/#Lists-of-bodies-and-their-transforms","page":"Lists of bodies and their transforms","title":"Lists of bodies and their transforms","text":"We might want to have several distinct bodies. Here, we discuss how to combine bodies into lists, and similarly, their transforms.\n\nusing RigidBodyTools\nusing Plots","category":"section"},{"location":"manual/bodylists/#Body-list","page":"Lists of bodies and their transforms","title":"Body list","text":"Suppose we have two bodies and we wish to combine them into a single list. The advantage of doing so is that many of the operations we have presented previously also extend to lists. We use BodyList to combine them.\n\nb1 = Circle(1.0,0.02)\nb2 = Rectangle(1.0,2.0,0.02)\nbl = BodyList([b1,b2])\n\nAnother way to do this is to push each one onto the list:\n\nbl = BodyList()\npush!(bl,b1)\npush!(bl,b2)\n\nWe can transform the list by creating a list of transforms with a MotionTransformList\n\nX1 = MotionTransform([2.0,3.0],0.0)\nX2 = MotionTransform([-2.0,-0.5],π/4)\ntl = MotionTransformList([X1,X2])\n\nThe transform list can be applied to the whole body list simply with\n\ntl(bl)\n\nwhich creates a copy of the body list and transforms that, or\n\nupdate_body!(bl,tl)\n\nwhich updates each body in bl in place.\n\nLet's see our effect\n\nplot(bl)\n\nIt is important to note that the list points to the original bodies, so that any change made to the list is reflected in the original bodies, e.g.\n\nplot(b2)","category":"section"},{"location":"manual/bodylists/#Utilities-on-lists","page":"Lists of bodies and their transforms","title":"Utilities on lists","text":"There are some specific utilities that are helpful for lists. For example, to collect all of the x, y points (the segment midpoints) in the list into two vectors, use\n\nx, y = collect(bl)\n\nIn a vector comprising data on these concatenated surface points, we can use view to look at just one body's part and change it:\n\nf = zero(x)\nf1 = view(f,bl,1)\nf1 .= 1.0;\nplot(f)\n\nAlso, we can sum up the values for one of the bodies:\n\nsum(f,bl,2)","category":"section"},{"location":"manual/bodylists/#Body-and-transform-list-functions","page":"Lists of bodies and their transforms","title":"Body and transform list functions","text":"\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"manual/bodylists/#RigidBodyTools.BodyList","page":"Lists of bodies and their transforms","title":"RigidBodyTools.BodyList","text":"BodyList([b1,b2,...])\n\nCreate a list of bodies\n\n\n\n\n\n","category":"type"},{"location":"manual/bodylists/#RigidBodyTools.getrange","page":"Lists of bodies and their transforms","title":"RigidBodyTools.getrange","text":"getrange(bl::BodyList,bid::Int) -> Range\n\nReturn the subrange of indices in the global set of surface point data corresponding to body bid in a BodyList bl.\n\n\n\n\n\ngetrange(ls::RigidBodyMotion,dimfcn::Function,jid::Int) -> Range\n\nReturn the subrange of indices in the global state vector for the state corresponding to joint jid in linked system ls.\n\n\n\n\n\n","category":"function"},{"location":"manual/bodylists/#Base.collect-Tuple{BodyList}","page":"Lists of bodies and their transforms","title":"Base.collect","text":"collect(bl::bodylist[,endpoints=false][,ref=false]) -> Vector{Float64}, Vector{Float64}\n\nCollect the inertial-space coordinates of all of the Lagrange points comprising the bodies in body list bl and return each assembled set of coordinates as a vector. By default, endpoints=false and ref=false, which means this collects the midpoints of segments in the inertial coordinates. If endpoints=true it collects segment endpoints instead. If ref=true it collects the coordinates in the body coordinate system.\n\n\n\n\n\n","category":"method"},{"location":"manual/bodylists/#Base.sum-Tuple{AbstractVector, BodyList, Int64}","page":"Lists of bodies and their transforms","title":"Base.sum","text":"sum(f::AbstractVector,bl::BodyList,i::Int) -> Real\n\nCompute a sum of the elements of vector f corresponding to body i in body list bl.\n\n\n\n\n\n","category":"method"},{"location":"manual/bodylists/#Base.view-Tuple{AbstractVector, BodyList, Int64}","page":"Lists of bodies and their transforms","title":"Base.view","text":"view(f::AbstractVector,bl::BodyList,bid::Int) -> SubArray\n\nProvide a view of the range of values in vector f corresponding to the Lagrange points of the body with index bid in a BodyList bl.\n\n\n\n\n\n","category":"method"},{"location":"manual/bodylists/#RigidBodyTools.MotionTransformList","page":"Lists of bodies and their transforms","title":"RigidBodyTools.MotionTransformList","text":"MotionTransformList([t1,t2,...])\n\nCreate a list of motion transforms\n\n\n\n\n\n","category":"type"},{"location":"manual/deformation/#Deforming-bodies","page":"Deforming bodies","title":"Deforming bodies","text":"Thus far we have only shown rigid body motion. However, we can also prescribe surface deformation as an additional component of a body's motion.\n\nusing RigidBodyTools\nusing Plots\n\nBefore we get started, let's define the same macro that we used earlier in order to visualize our system's motion\n\nmacro animate_motion(b,m,dt,tmax,xlim,ylim)\n    return esc(quote\n            bc = deepcopy($b)\n            t0, x0 = 0.0, init_motion_state(bc,$m)\n            dxdt = zero(x0)\n            x = copy(x0)\n\n            @gif for t in t0:$dt:t0+$tmax\n                motion_rhs!(dxdt,x,($m,bc),t)\n                global x += dxdt*$dt\n                update_body!(bc,x,$m)\n                plot(bc,xlims=$xlim,ylims=$ylim)\n            end every 5\n        end)\nend\n\nFor deforming bodies, we specify the velocity of the surface directly. This deformation velocity is expressed in the coordinate system attached to the body, rather than the inertial coordinate system. This enables the motion to be easily superposed with the rigid-body motion described earlier.\n\nIt is also important to note that the motion is applied to the endpoints of the surface segments. The midpoints are then constructed from the updated endpoints.","category":"section"},{"location":"manual/deformation/#Example:-Basic-deformation","page":"Deforming bodies","title":"Example: Basic deformation","text":"Let's see an example. We will create an oscillatory deformation of a circle. We create the motion by creating functions for each component of velocity.\n\nΩ = 2π\nufcn(x,y,t) = 0.25*x*y*Ω*cos(Ω*t)\nvfcn(x,y,t) = 0.25*(x^2-y^2)*Ω*cos(Ω*t)\ndef = DeformationMotion(ufcn,vfcn)\n\nWe will create a simple fixed revolute joint that anchors the body's center to the inertial system. (Note that we don't need to create a body list here, since we are only working with one body and one joint.)\n\nXp_to_jp = MotionTransform(0.0,0.0,0.0)\nXc_to_jc = MotionTransform(0.0,0.0,0.0)\ndofs = [ConstantVelocityDOF(0.0)]\njoint = Joint(RevoluteJoint,0,Xp_to_jp,1,Xc_to_jc,dofs)\n\nbody = Circle(1.0,0.02)\n\nTo construct the system, we supply the joint and body, as before, as well as the deformation.\n\nls = RigidBodyMotion(joint,body,def)\n\nLet's animate this motion\n\n@animate_motion body ls 0.01 4 (-2,2) (-2,2)\n\nThe body remains fixed, but the surface deforms!","category":"section"},{"location":"manual/deformation/#Example:-Expanding-motion","page":"Deforming bodies","title":"Example: Expanding motion","text":"Now a circle undergoing an expansion. For this, we set constant velocity components equal to constants, the coordinates of the surface segment endpoints\n\nbody = Circle(1.0,0.02)\n\nu = copy(body.x̃end)\nv = copy(body.ỹend)\ndef = ConstantDeformationMotion(u,v)\n\nls = RigidBodyMotion(joint,body,def)\n@animate_motion body ls 0.01 2 (-5,5) (-5,5)","category":"section"},{"location":"manual/deformation/#Example:-Combining-rigid-motion-and-deforming-motion.","page":"Deforming bodies","title":"Example: Combining rigid motion and deforming motion.","text":"Now, let's combine an oscillatory rigid-body rotation with oscillatory deformation, this time applied to a square.\n\nXp_to_jp = MotionTransform(0.0,0.0,0.0)\nXc_to_jc = MotionTransform(0.0,0.0,0.0)\nΩ = 1.0\ndofs = [OscillatoryDOF(π/4,Ω,0.0,0.0)]\njoint = Joint(RevoluteJoint,0,Xp_to_jp,1,Xc_to_jc,dofs)\n\nbody = Square(1.0,0.02)\n\nufcn(x,y,t) = 0.25*(x^2+y^2)*y*Ω*cos(Ω*t)\nvfcn(x,y,t) = -0.25*(x^2+y^2)*x*Ω*cos(Ω*t)\ndef = DeformationMotion(ufcn,vfcn)\n\nls = RigidBodyMotion(joint,body,def)\n\n@animate_motion body ls π/100 4π (-2,2) (-2,2)","category":"section"},{"location":"manual/deformation/#Example:-Defining-new-deformations","page":"Deforming bodies","title":"Example: Defining new deformations","text":"We can also define new types of deformation that are more specialized. We need only define a subtype of AbstractDeformationMotion and extend the function deformation_velocity to work with it. The signature of this function is deformation_velocity(body,deformation,time).\n\nFor example, let's define a motion on a rectangular shape that will deform only the top side in the normal direction, but leave the rest of the surface stationary. We will use the side field of the Polygon shape type to access the top, and set its vertical velocity.\n\nstruct TopMotion{UT} <: AbstractDeformationMotion\n    vtop :: UT\nend\n\nfunction RigidBodyTools.deformation_velocity(body::Polygon,def::TopMotion,t::Real)\n\n    u, v = zero(body.x̃end), zero(body.ỹend)\n    top = body.side[3]\n    v[top] .= def.vtop.(body.x̃end[top],body.ỹend[top],t)\n    return vcat(u,v)\nend\n\nNow apply it\n\nXp_to_jp = MotionTransform(0.0,0.0,0.0)\nXc_to_jc = MotionTransform(0.0,0.0,0.0)\ndofs = [ConstantVelocityDOF(0.0)]\njoint = Joint(RevoluteJoint,0,Xp_to_jp,1,Xc_to_jc,dofs)\n\nbody = Rectangle(1.0,2.0,0.02)\nvfcn(x,y,t) = 0.2*(1-x^2)*cos(t)\ndef = TopMotion(vfcn)\n\nls = RigidBodyMotion(joint,body,def)\n\nLet's try it out\n\n@animate_motion body ls π/100 4π (-1.5,1.5) (-2.5,2.5)\n\nAs desired, the top surface deforms vertically, but the rest of the surface is stationary.","category":"section"},{"location":"manual/deformation/#Deformation-functions","page":"Deforming bodies","title":"Deformation functions","text":"\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"manual/deformation/#RigidBodyTools.DeformationMotion","page":"Deforming bodies","title":"RigidBodyTools.DeformationMotion","text":"DeformationMotion(u::Function,v::Function)\n\nCreate an instance of directly-specified velocity whose components are specified with functions. These functions u and v must each be of the form f(x̃,ỹ,t), where x̃ and ỹ are coordinates of a point in the body coordinate system and t is time, and they must return the corresponding velocity component in the body coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"manual/deformation/#RigidBodyTools.ConstantDeformationMotion","page":"Deforming bodies","title":"RigidBodyTools.ConstantDeformationMotion","text":"ConstantDeformationMotion(u::Vector{Float64},v::Vector{Float64})\n\nCreate an instance of basic directly-specified (constant) velocity, to be associated with a body whose length is the same as u and v.\n\n\n\n\n\n","category":"type"},{"location":"manual/shapes/#Creating-bodies","page":"Creating bodies","title":"Creating bodies","text":"The most basic functions of this package create an object of type Body. There are a variety of such functions, a few of which we will demonstrate here. Generally speaking, we are interesting in creating the object and placing it in a certain position and orientation. We do this in two steps: we create the basic shape, centered at the origin with a default orientation, and then we transform the shape to a desired location and orientation. We will discuss the shapes in this notebook, and the transforms in the following notebook.\n\nIt is useful to stress that each body stores two types of points internally: the endpoints of the segments that comprise the body surface, and the midpoints of these segments. The midpoints are intended for use in downstream calculations, e.g. as forcing points in the calculations on immersed layers. The midpoints are simply the geometric averages of the endpoints, so endpoints are the ones that are transformed first, and midpoints are updated next.\n\nusing RigidBodyTools\nusing Plots","category":"section"},{"location":"manual/shapes/#Creating-a-shape","page":"Creating bodies","title":"Creating a shape","text":"Let's first create a shape. For any shape, we have to make a choice of the geometric dimensions (e.g, radius of the circle, side lengths of a rectangle), as well as the points that we use to discretely represent the surface. For this latter choice, there are two constructor types: we can specify the number of points (as an integer), or we can specify the nominal spacing between points (as a floating-point number).\n\nThe second approach is usually preferable when we use these tools for constructing immersed bodies. It is important to stress that the algorithms for placing points attempt to make the spacing as uniform as possible.\n\nLet's create the most basic shape, a circle of radius 1. We will discretize it with 100 points first:\n\nb = Circle(1.0,100)\n\nNow we will create the same body with a spacing of 0.02\n\nb = Circle(1.0,0.02)\n\nThis choice led to 312 points along the circumference. Quick math will tell you that the point spacing is probably not exactly 0.02. In fact, you can find out the actual spacing with dlengthmid. This function calculates the spacing associated with each point. (It does so by first calculating the spacing between midpoints between each point and its two adjacent points.)\n\ndlengthmid(b)\n\nIt is just a bit larger than 0.02.\n\nA few other useful functions on the shape. To simply know the number of points,\n\nlength(b)\n\nTo find the outward normal vectors (based on the perpendicular to the line joining the adjacent midpoints):\n\nnx, ny = normalmid(b)\n\nWe can also plot the shape\n\nplot(b)\n\nSometimes we don't want to fill in the shape (and maybe change the line color). In that case, we can use\n\nplot(b,fill=:false,linecolor=:black)","category":"section"},{"location":"manual/shapes/#Other-shapes","page":"Creating bodies","title":"Other shapes","text":"Let's see some other shapes in action, like a square and an ellipse\n\nb1, b2 = Square(1.0,0.02), Ellipse(0.6,0.1,0.02)\nplot(plot(b1), plot(b2))\n\nA NACA 4412 airfoil, with chord length 1, and 0.02 spacing between points.\n\nb = NACA4(0.04,0.4,0.12,0.02)\nplot(b)\n\nA flat plate with no thickness\n\nb = Plate(1.0,0.02)\nplot(b)\n\nand a flat plate with a 5 percent thickness (and rounded ends)\n\nb = ThickPlate(1.0,0.05,0.01)\nplot(b)\n\nThere are also some generic tools for creating shapes. A BasicBody simply consists of points that describe the vertices. The interface for this is very simple.\n\nx = [1.0, 1.2, 0.7, 0.6, 0.2, -0.1, 0.1, 0.4]\ny = [0.1, 0.5, 0.8, 1.2, 0.8, 0.6, 0.2, 0.3]\nb = BasicBody(x,y)\n\nplot(b)\nscatter!(b,markersize=3,markercolor=:black)\n\nHowever, this function does not insert any points along the sides between vertices. We have to do the work of specifying these points in the original call. For this reason, there are a few functions that are more directly useful. For example, we can create a polygon from these vertices, with a specified spacing between points distributed along the polygon sides\n\nb = Polygon(x,y,0.02)\n\nplot(b)\nscatter!(b,markersize=3,markercolor=:black)\n\nAlternatively, we can interpret those original points as control points for splines, with a spacing between points along the splines provided:\n\nb = SplinedBody(x,y,0.02)\n\nplot(b)\nscatter!(b,markersize=3,markercolor=:black)","category":"section"},{"location":"manual/shapes/#Body-functions","page":"Creating bodies","title":"Body functions","text":"","category":"section"},{"location":"manual/shapes/#Shape-utilities","page":"Creating bodies","title":"Shape utilities","text":"\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"manual/shapes/#RigidBodyTools.BasicBody","page":"Creating bodies","title":"RigidBodyTools.BasicBody","text":"BasicBody(x,y[,closuretype=ClosedBody]) <: Body\n\nConstruct a body by simply passing in the x and y coordinate vectors. The last point will be automatically connected to the first point. The coordinate vectors are assumed to be expressed in the body-fixed coordinate system. The optional closuretype specifies whether the body is closed (ClosedBody) or open (OpenBody). If closed, then the first and last points are assumed joined in operations that require neighbor points.\n\n\n\n\n\n","category":"type"},{"location":"manual/shapes/#RigidBodyTools.Polygon","page":"Creating bodies","title":"RigidBodyTools.Polygon","text":"Polygon(x::Vector,y::Vector,n[,closuretype=ClosedBody])\n\nCreate a polygon shape with vertices x and y, with approximately n points distributed along the perimeter.\n\n\n\n\n\n","category":"type"},{"location":"manual/shapes/#RigidBodyTools.Circle","page":"Creating bodies","title":"RigidBodyTools.Circle","text":"Circle(a,n) <: Body\n\nConstruct a circular body with radius a and with n points distributed on the body perimeter.\n\n\n\n\n\nCircle(a,targetsize::Float64) <: Body\n\nConstruct a circular body with radius a with spacing between points set approximately to targetsize.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.Ellipse","page":"Creating bodies","title":"RigidBodyTools.Ellipse","text":"Ellipse(a,b,n[,endpointson=false],[shifted=false]) <: Body\n\nConstruct an elliptical body with semi-major axis a and semi-minor axis b, with n points distributed on the body perimeter. Can also call this with Ellipse(a,b,ds) where ds is the desired spacing between points. If endpointson=true, then the endpoints will be placed on the surface and the midpoints will lie inside the nominal ellipse. By default, the midpoints lie on the ellipse. If shifted=true, then the first endpoint lies on an axis of symmetry. By default the first midpoint lies on the axis symmetry.\n\n\n\n\n\n","category":"type"},{"location":"manual/shapes/#RigidBodyTools.NACA4","page":"Creating bodies","title":"RigidBodyTools.NACA4","text":"NACA4(cam,pos,thick,ds::Float64,[len=1.0]) <: Body{N}\n\nGenerates points in the shape of a NACA 4-digit airfoil. The relative camber is specified by cam, the position of maximum camber (as fraction of chord) by pos, and the relative thickness by thick. The parameter ds specifies the distance between points. The optional parameter len specifies the chord length, which defaults to 1.0.\n\nExample\n\njulia> b = NACA4(0.0,0.0,0.12,0.02);\n\n\n\n\n\n","category":"type"},{"location":"manual/shapes/#RigidBodyTools.Plate","page":"Creating bodies","title":"RigidBodyTools.Plate","text":"Plate(a,n) <: Body\n\nConstruct a flat plate of zero thickness with length a, divided into n equal segments.\n\n\n\n\n\nPlate(a,ds) <: Body\n\nConstruct a flat plate of zero thickness with length a, with approximate spacing ds between points.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.Rectangle","page":"Creating bodies","title":"RigidBodyTools.Rectangle","text":"Rectangle(a,b,n) <: Body\n\nConstruct a rectangular body with x̃ side half-length a and ỹ side half-length b, with approximately n points distributed along the perimeter. The centroid of the rectangle is placed at the origin (so that the lower left corner is at (-a,-b)).\n\nPoints are not placed at the corners, but rather, are shifted by half a segment. This ensures that all normals are perpendicular to the sides.\n\n\n\n\n\nRectangle(a,b,ds) <: Body\n\nConstruct a rectangular body with x̃ side half-length a and ỹ side half-length b, with approximate spacing ds between points.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.SplinedBody","page":"Creating bodies","title":"RigidBodyTools.SplinedBody","text":"SplinedBody(X,Δx[,closuretype=ClosedBody]) -> BasicBody\n\nUsing control points in X (assumed to be N x 2, where N is the number of points), create a set of points that are uniformly spaced (with spacing Δx) on a curve that passes through the control points. A cubic parametric spline algorithm is used. If the optional parameter closuretype is set to OpenBody, then the end points are not joined together.\n\n\n\n\n\nSplinedBody(x,y,Δx[,closuretype=ClosedBody]) -> BasicBody\n\nUsing control points in x and y, create a set of points that are uniformly spaced (with spacing Δx) on a curve that passes through the control points. A cubic parametric spline algorithm is used. If the optional parameter closuretype is set to OpenBody, then the end points are not joined together.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.Square","page":"Creating bodies","title":"RigidBodyTools.Square","text":"Square(a,n) <: Body\n\nConstruct a square body with side half-length a and with approximately n points distributed along the perimeter.\n\n\n\n\n\nSquare(a,ds) <: Body\n\nConstruct a square body with side half-length a, with approximate spacing ds between points.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.centraldiff","page":"Creating bodies","title":"RigidBodyTools.centraldiff","text":"centraldiff(body::Body[;axes=:inertial]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the circular central differences of coordinates on body body (or on each body in list body). If axes=:body, uses the reference coordinates in body-fixed space.\n\n\n\n\n\ncentraldiff(bl::BodyList[;axes=:inertial]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the centraldiff on each constituent body in bl.  If axes=:body, uses the reference coordinates in body-fixed space.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#Base.diff-Tuple{Body}","page":"Creating bodies","title":"Base.diff","text":"diff(body::Body[;axes=:inertial]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the x and y differences of the faces on the perimeter of body body, whose ends are at the current x and y coordinates (in inertial space) of the body (if axes=:inertial), or at the reference x̃ and ỹ coordinates (body-fixed space) if axes=:body. Face 1 corresponds to the face between points 1 and 2, for example.\n\nIf body is a BodyList, then it computes the differences separately on each constituent body.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#Base.diff-Tuple{BodyList}","page":"Creating bodies","title":"Base.diff","text":"diff(bl::BodyList[;axes=:inertial]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the diff on each constituent body in bl.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#RigidBodyTools.dlength","page":"Creating bodies","title":"RigidBodyTools.dlength","text":"dlength(body::Body/BodyList[;axes=:inertial]) -> Vector{Float64}\n\nCompute the lengths of the faces on the perimeter of body body, whose ends are at the current xend and yend coordinates (in inertial space) of the body. Face 1 corresponds to the face between endpoints 1 and 2, for example. If axes=:body, uses the reference coordinates in body-fixed space.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.dlengthmid","page":"Creating bodies","title":"RigidBodyTools.dlengthmid","text":"dlengthmid(body::Body/BodyList[;axes=:inertial]) -> Vector{Float64}\n\nSame as dlength.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#Base.length-Tuple{Body}","page":"Creating bodies","title":"Base.length","text":"length(body::Body)\n\nReturn the number of points on the body perimeter\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#RigidBodyTools.midpoints-Tuple{Body}","page":"Creating bodies","title":"RigidBodyTools.midpoints","text":"midpoints(body::Body[;axes=:inertial]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the x and y midpoints of the faces on the perimeter of body body, whose ends are at the current x and y coordinates (in inertial space) of the body (if axes=:inertial), or at the reference x̃ and ỹ coordinates (body-fixed space) if axes=:body. Face 1 corresponds to the face between points 1 and 2, for example.\n\nIf body is a BodyList, then it computes the differences separately on each constituent body.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#RigidBodyTools.midpoints-Tuple{BodyList}","page":"Creating bodies","title":"RigidBodyTools.midpoints","text":"midpoints(bl::BodyList[;axes=:inertial]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the midpoints on each constituent body in bl.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#RigidBodyTools.normal","page":"Creating bodies","title":"RigidBodyTools.normal","text":"normal(body::Body/BodyList[;axes=:inertial]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the current normals in inertial components (if axes=:inertial) or body-   fixed components (if axes=:body) of the faces on the perimeter of body body, whose ends are at the current xend and yend coordinates (in inertial space) of the body. Face 1 corresponds to the face between points 1 and 2, for example. For an OpenBody, this provides a vector that is one element shorter than the number of points.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.normalmid","page":"Creating bodies","title":"RigidBodyTools.normalmid","text":"normalmid(body::Body/BodyList[;axes=:inertial]) -> Tuple{Vector{Float64},Vector{Float64}}\n\nCompute the current normals in inertial components (if axes=:inertial) or body-   fixed components (if axes=:body) of the faces formed between endpoints on the perimeter of body body (or each body in list body).\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.curvature","page":"Creating bodies","title":"RigidBodyTools.curvature","text":"curvature(body::Body/BodyList[;axes=:inertial]) -> Vector{Float64}\n\nCompute the current curvature of the faces on the perimeter of body body. Face 1 corresponds to the face between points 1 and 2, for example. For an OpenBody, this provides a vector that is one element shorter than the number of points.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.arccoord","page":"Creating bodies","title":"RigidBodyTools.arccoord","text":"arccoord(body::Body/BodyList[;axes=:inertial]) -> Vector{Float64}\n\nReturns a vector containing the arclength coordinate along the surface of body, evaluated at the second endpoint of each face. So, e.g., the first coordinate would be the length of face 1, the second the length of face 2, and the last would be total length of all of the faces. Use inertial components (if axes=:inertial) or body-fixed components (if axes=:body). If this is a body list, restart the origin of the coordinates on each body in the list.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.arccoordmid","page":"Creating bodies","title":"RigidBodyTools.arccoordmid","text":"arccoordmid(body::Body/BodyList[;axes=:inertial]) -> Vector{Float64}\n\nReturns a vector containing the arclength coordinate along the surface of body, evaluated at the midpoints between the ends of faces. So, e.g., the first coordinate would be half of the length of face 1, the second would be half of face 2 plus all of face 1, etc. Use inertial components (if axes=:inertial) or body-   fixed components (if axes=:body). If this is a body list, restart   the origin of the coordinates on each body in the list.\n\n\n\n\n\n","category":"function"},{"location":"manual/shapes/#RigidBodyTools.arclength-Tuple{Body}","page":"Creating bodies","title":"RigidBodyTools.arclength","text":"arclength(body::Body[;axes=:inertial])\n\nCompute the total arclength of body, from the sum of the lengths of the faces. If axes=:body, use the body-fixed coordinates.\n\n\n\n\n\n","category":"method"},{"location":"manual/shapes/#RigidBodyTools.arclength-Tuple{BodyList}","page":"Creating bodies","title":"RigidBodyTools.arclength","text":"arclength(bl::BodyList[;axes=:inertial]) -> Vector{Float64}\n\nCompute the total arclength of each body in bl and assemble the results into a vector. If axes=:body, use the body-fixed coordinates.\n\n\n\n\n\n","category":"method"},{"location":"manual/surfacevelocities/#Evaluating-velocities-on-body-surfaces","page":"Evaluating velocities on body surfaces","title":"Evaluating velocities on body surfaces","text":"For use in mechanics problems, it is important to be able to output the velocity of the points on the surfaces of bodies at a given system state and time. We use the function surface_velocity! for this. Here, we will demonstrate its use, and particularly, its various options.\n\nWe will use a simple problem, consisting of two flat plates connected by a RevoluteJoint, and one of the plates connected to the inertial system by a FreeJoint2d, oscillating in y coordinate only.\n\nusing RigidBodyTools\nusing Plots","category":"section"},{"location":"manual/surfacevelocities/#Set-up-the-bodies,-joints,-and-motion","page":"Evaluating velocities on body surfaces","title":"Set up the bodies, joints, and motion","text":"body1 = Plate(1.0,200)\nbody2 = deepcopy(body1)\n\nbodies = BodyList([body1,body2])\n\nJoint 1, connecting body 1 to inertial system\n\nXp_to_j1 = MotionTransform(0.0,0.0,0.0)\nXch_to_j1 = MotionTransform(-0.5,0.0,0.0)\ndofs1 = [ConstantVelocityDOF(0),ConstantVelocityDOF(0),OscillatoryDOF(1.0,2π,0,0.0)]\njoint1 = Joint(FreeJoint2d,0,Xp_to_j1,1,Xch_to_j1,dofs1)\n\nJoint 2, connecting body 2 to body 1\n\nXp_to_j2 = MotionTransform(0.5,0.0,0.0)\nXch_to_j2 = MotionTransform(-0.5,0.0,0.0)\ndofs2 = [OscillatoryDOF(π/4,2π,-π/4,0.0)]\njoint2 = Joint(RevoluteJoint,1,Xp_to_j2,2,Xch_to_j2,dofs2)\n\nAssemble, and get the initial joint state vector at t = 0\n\njoints = [joint1,joint2]\nls = RigidBodyMotion(joints,bodies)\nt = 0\nx = init_motion_state(bodies,ls;tinit=t)\n\nLet's plot the bodies, just to visualize their current configuration.\n\nupdate_body!(bodies,x,ls)\nplot(bodies,xlim=(-1,3),ylim=(-2,2))\n\nBecause of the phase difference, joint 2 is bent at an angle initially.","category":"section"},{"location":"manual/surfacevelocities/#Evaluate-velocity-on-body-points","page":"Evaluating velocities on body surfaces","title":"Evaluate velocity on body points","text":"First, initialize vectors for the u and v components in this 2d example, using the zero_body function.\n\nu, v = zero_body(bodies), zero_body(bodies)\n\nNow evaluate the velocities at time 0\n\nsurface_velocity!(u,v,bodies,x,ls,t)\n\nWe can plot these on each body using the view function for BodyList. For example, the vectors of u and v velocities on body 1 are\n\nbodyid = 1\ns = arccoord(bodies[bodyid])\nplot(s,view(u,bodies,bodyid),ylim=(-20,20),label=\"u1\")\nplot!(s,view(v,bodies,bodyid),label=\"v1\")\n\nThis shows a pure vertical translation. On body 2, we see a mixture of the translation of body 1, plus the rotation of joint 2, which is reflected in the linear variation. Since the plate is at an angle, some of this rotation shows up as a negative u component.\n\nbodyid = 2\ns = arccoord(bodies[bodyid])\nplot(s,view(u,bodies,bodyid),ylim=(-20,20),label=\"u2\")\nplot!(s,view(v,bodies,bodyid),label=\"v2\")\n\nWe can compute these velocities in different components, using the optional axes argument. For example, let's see the velocities on body 2 in its own coordinate system\n\nsurface_velocity!(u,v,bodies,x,ls,t;axes=2)\nbodyid = 2\ns = arccoord(bodies[bodyid])\nplot(s,view(u,bodies,bodyid),ylim=(-20,20),label=\"u2\")\nplot!(s,view(v,bodies,bodyid),label=\"v2\")\n\nNow only the v component (the component perpendicular to the plate) depicts the rotation, and the u component has only a portion of the translational motion from joint 1.\n\nWe can also compute the velocity relative to a body reference frame, using the optional frame argument. Let's compute the velocities relative to the velocity of body 1 (and in body 1 coordinates) and plot them.\n\nsurface_velocity!(u,v,bodies,x,ls,t;axes=1,frame=1)\nbodyid = 1\ns = arccoord(bodies[bodyid])\nplot(s,view(u,bodies,bodyid),ylim=(-20,20),label=\"u1\")\nplot!(s,view(v,bodies,bodyid),label=\"v1\")\n\nBody 1 has no velocity in this reference frame. And body 2 has only a pure rotation...\n\nbodyid = 2\ns = arccoord(bodies[bodyid])\nplot(s,view(u,bodies,bodyid),ylim=(-20,20),label=\"u2\")\nplot!(s,view(v,bodies,bodyid),label=\"v2\")\n\nWe do not have to remove all of the motion of the reference body when we compute velocity in a moving reference frame. We can use the motion_part keyword argument to remove only, e.g., :angular or :linear part (instead of :full, the default). For example, if we remove the angular part of body 2's motion, we are left with only the translation from joint 1\n\nsurface_velocity!(u,v,bodies,x,ls,t;axes=2,frame=2,motion_part=:angular)\nbodyid = 2\ns = arccoord(bodies[bodyid])\nplot(s,view(u,bodies,bodyid),ylim=(-20,20),label=\"u2\")\nplot!(s,view(v,bodies,bodyid),label=\"v2\")","category":"section"},{"location":"manual/surfacevelocities/#Surface-velocity-functions","page":"Evaluating velocities on body surfaces","title":"Surface velocity functions","text":"\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"manual/surfacevelocities/#RigidBodyTools.surface_velocity!","page":"Evaluating velocities on body surfaces","title":"RigidBodyTools.surface_velocity!","text":"surface_velocity!(u::AbstractVector,v::AbstractVector,bl::BodyList,x::AbstractVector,m::RigidBodyMotion,t::Real[;axes=0,frame=axes,motion_part=:full])\n\nCalculate the surface velocity components u and v for the points on bodies bl. The function evaluates prescribed kinematics at time t and extracts non-prescribed (exogenous and unconstrained) velocities from state vector x. There are three keyword arguments that can change the behavior of this function: axes determines whether the components returned are expressed in the inertial coordinate system (0, the default) or another body's coordinates (the body ID); frame specifies that the motion should be measured relative to another reference body's velocity (by default, 0); and motion_part determines whether the entire reference body velocity is used (:full, the default), only the angular part (:angular), or only the linear part (:linear).\n\n\n\n\n\n","category":"function"},{"location":"#RigidBodyTools.jl","page":"Home","title":"RigidBodyTools.jl","text":"Tools for creating, moving, and discretizing rigid bodies\n\nThe purpose of this package is to provide tools for rigid bodies with point-discretized surfaces. It includes methods for\n\na library of surface shape definitions and associated point discretizations\ncalculation of geometric properties\nrigid-body motion and transformation of surface points\ncollections of multiple rigid bodies","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"This package works on Julia 1.0 and above and is registered in the general Julia registry. To install from the REPL, type e.g.,\n\n] add RigidBodyTools\n\nThen, in any version, type\n\njulia> using RigidBodyTools\n\nThe plots in this documentation are generated using Plots.jl. You might want to install that, too, to follow the examples.","category":"section"},{"location":"manual/exogenous/#Exogenous-degrees-of-freedom","page":"Exogenous degrees of freedom","title":"Exogenous degrees of freedom","text":"As we mentioned in previous pages, some degrees of freedom can be designated as exogenous, meaning that their behavior is determined by some external process that we do not model explicitly. In practice, that means that the acceleration of such a degree of freedom must by explicitly provided at every time step while the state vector is being advanced.\n\nusing RigidBodyTools\nusing Plots\n\nAs usual, we will demonstrate this via an example. In the example, a single flat plate will be commanded to pitch upward by 45 degrees about its leading edge. It will move steadily in the +x direction. However, its y acceleration will vary randomly via some exogenous process.\n\nXp_to_jp = MotionTransform(0.0,0.0,0.0)\nXc_to_jc = MotionTransform(0.5,0.0,0.0)\ndofs = [SmoothRampDOF(0.4,π/4,0.5),ConstantVelocityDOF(1.0),ExogenousDOF()]\njoint = Joint(FreeJoint2d,0,Xp_to_jp,1,Xc_to_jc,dofs)\n\nbody = ThickPlate(1.0,0.05,0.02)\n\nWe need to provide a means of passing along the time-varying information about the exogenous acclerations to the time integrator. There are two ways we can do this.","category":"section"},{"location":"manual/exogenous/#Method-1:-A-function-for-exogenous-acclerations.","page":"Exogenous degrees of freedom","title":"Method 1: A function for exogenous acclerations.","text":"We can provide a function that will specify the exogenous y acceleration. Here, we will create a function that sets it to a random value chosen from a normal distribution. Note that the function must be mutating and have a signature (a,x,p,t), where a is the exogenous acceleration vector. The arguments x and p are a state and a parameter, which can be flexibly defined. Here, the state is the rigid-body system state and the parameter is the RigidBodyMotion structure. The last argument t is time.\n\nIn this example, we don't need any of those arguments.\n\nfunction my_exogenous_function!(a,x,ls,t)\n    a .= randn(length(a))\nend\n\nWe pass that along via the exogenous keyword argument.\n\nls = RigidBodyMotion(joint,body;exogenous=my_exogenous_function!)","category":"section"},{"location":"manual/exogenous/#Method-2:-Setting-the-exogenous-accelerations-explicitly-in-the-loop","page":"Exogenous degrees of freedom","title":"Method 2: Setting the exogenous accelerations explicitly in the loop","text":"Another approach we can take is to set the exogenous acceleration(s) explicitly in the loop, using the update_exogenous! function. This function saves the vector of accelerations in a buffer in the RigidBodyMotion structure so that it is available to the time integrator. We will demonstrate that approach here.\n\nls = RigidBodyMotion(joint,body)\n\nLet's initialize the state vector and its rate of change\n\nbc = deepcopy(body)\ndt, tmax = 0.01, 3.0\nt0, x0 = 0.0, init_motion_state(bc,ls)\ndxdt = zero(x0)\nx = copy(x0)\n\nNote that the state vector has four elements. The first two are associated with the prescribed motions for rotation and x translation. The third is the y position, the exogenous degree of freedom. And the fourth is the y velocity.\n\nWhy the y velocity? Because the exogenous behavior is specified via its acceleration. Let's advance the system and animate it. We include a horizontal line along the hinge axis to show the effect of the exogenous motion.\n\nxhist = []\na_edof = zero_exogenous(ls)\n@gif for t in t0:dt:t0+tmax\n\n  a_edof .= randn(length(a_edof))\n\n  update_exogenous!(ls,a_edof)\n  motion_rhs!(dxdt,x,(ls,bc),t)\n  global x += dxdt*dt\n  update_body!(bc,x,ls)\n\n  push!(xhist,copy(x))\n  plot(bc,xlims=(-1,5),ylims=(-1.5,1.5))\n  hline!([0.0])\nend every 5\n\nLet's plot the exogenous state and its velocity\n\nplot(t0:dt:t0+tmax,map(x -> exogenous_position_vector(x,ls,1)[1],xhist),label=\"y position\",xlabel=\"t\")\nplot!(t0:dt:t0+tmax,map(x -> exogenous_velocity_vector(x,ls,1)[1],xhist),label=\"y velocity\")\n\nThe variation in velocity is quite noisy (and constitutes a random walk). In contrast, the change in position is relatively smooth, since it represents an integral of this velocity.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"manual/dofmotions/#Behaviors-of-degrees-of-freedom","page":"Behaviors of degrees of freedom","title":"Behaviors of degrees of freedom","text":"To define the motion of a joint requires that we define the behavior of each of the joint's degrees of freedom. There are three different types of behavior of a degree of freedom: (1) Its motion is prescribed with a given function of time, in which case we say that the     degree of freedom is constrained (2) Its motion is specified directly, but determined by a process that lies outside     of the body system, in which case we say the degree of freedom is exogenous. (3) Its motion is determined indirectly by some sort of force model for its behavior,     such as a spring or damper, in which case we say the degree of freedom is unconstrained.\n\nHere, we will discuss how to set a degree of freedom with one of these behaviors, and how to set the prescribed motion, if desired.\n\nusing RigidBodyTools\nusing Plots","category":"section"},{"location":"manual/dofmotions/#Constrained-behavior-(i.e.,-prescribed-motion)","page":"Behaviors of degrees of freedom","title":"Constrained behavior (i.e., prescribed motion)","text":"When a degree of freedom is constrained, then its behavior over time is set by some time-varying function. There are a number of different types of predefined time-varying behaviors.","category":"section"},{"location":"manual/dofmotions/#Constant-velocity","page":"Behaviors of degrees of freedom","title":"Constant velocity","text":"To specify constant velocity with some velocity, e.g. U=1, set\n\nU = 1.0\nk = ConstantVelocityDOF(U)\n\nFor any prescribed motion, we can evaluate it at any specified time. It returns data of type DOFKinematicData.\n\nt = 1.0\nkt = k(t)\n\nThe kinematic data can be parsed with dof_position, dof_velocity, and dof_acceleration:\n\ndof_position(kt)\n\ndof_velocity(kt)\n\ndof_acceleration(kt)\n\nLet's plot the position over time\n\nt = range(0,3,length=301)\nplot(t,dof_position.(k.(t)),xlims=(0,Inf),ylims=(0,Inf))","category":"section"},{"location":"manual/dofmotions/#Oscillatory-motion","page":"Behaviors of degrees of freedom","title":"Oscillatory motion","text":"We can set the position to be a sinusoidal function. For this, we set the amplitude, the angular frequency, the phase, and the mean velocity (typically zero).\n\nA = 1.0 ## amplitude\nΩ = 2π ## angular frequency\nϕ = π/2 ## phase\nvel = 0  ## mean velocity\nk = OscillatoryDOF(A,Ω,ϕ,vel)\n\nPlot the position, velocity, and acceleration\n\nplot(t,dof_position.(k.(t)),xlims=(0,Inf),label=\"x\")\nplot!(t,dof_velocity.(k.(t)),label=\"ẋ\")\nplot!(t,dof_acceleration.(k.(t)),label=\"ẍ\")","category":"section"},{"location":"manual/dofmotions/#Smooth-ramp-motion","page":"Behaviors of degrees of freedom","title":"Smooth ramp motion","text":"To ramp the position from one value to another, we use the SmoothRampDOF. For this, we need to specify the nominal velocity of the ramp, the change in position, and the time at which the ramp starts. There is an optional argument ramp to control the ramp's smoothness. It defaults to EldredgeRamp(11.0), an Eldredge-type ramp with smoothness factor 11.\n\nvel = 1.0  ## nominal ramp velocity\nΔx = 1.0 ## change in position\nt0 = 1.0 ## time of ramp start\nk = SmoothRampDOF(vel,Δx,t0)\n\nPlot the position\n\nplot(t,dof_position.(k.(t)),xlims=(0,Inf),label=\"x\")\n\nWe can also ramp up the velocity from one value to another, using SmoothVelocityRampDOF. For example,\n\nu1 = 1.0 ## initial velocity\nu2 = 2.0 ## final velocity\nacc = 1.0 ## nominal acceleration of the ramp\nt0 = 1.0 ## time of ramp start\nk = SmoothVelocityRampDOF(acc,u1,u2,t0)\n\nPlot the velocity\n\nplot(t,dof_velocity.(k.(t)),xlims=(0,Inf),label=\"u\")\n\nand the position\n\nplot(t,dof_position.(k.(t)),xlims=(0,Inf),label=\"x\")","category":"section"},{"location":"manual/dofmotions/#User-defined-motion","page":"Behaviors of degrees of freedom","title":"User-defined motion","text":"The user can specify the time-varying position by supplying a function of time and using CustomDOF. It automatically differentiates this function to get velocity and acceleration. For example, a quadratic behavior\n\nf(t) = 1.0*t + 2.0*t^2\nk = CustomDOF(f)\n\nPlot the position\n\nplot(t,dof_position.(k.(t)),xlims=(0,Inf),label=\"x\")\n\nand the velocity\n\nplot(t,dof_velocity.(k.(t)),xlims=(0,Inf),label=\"ẋ\")\n\nand the acceleration\n\nplot(t,dof_acceleration.(k.(t)),xlims=(0,Inf),label=\"ẍ\")","category":"section"},{"location":"manual/dofmotions/#Exogenous-and-unconstrained-behaviors","page":"Behaviors of degrees of freedom","title":"Exogenous and unconstrained behaviors","text":"If the degree of freedom is to be exogenous or unconstrained, then it can be designated as such, e.g,\n\nk = ExogenousDOF()\n\nor\n\nk = UnconstrainedDOF()","category":"section"},{"location":"manual/dofmotions/#Degree-of-freedom-functions","page":"Behaviors of degrees of freedom","title":"Degree of freedom functions","text":"\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"manual/dofmotions/#RigidBodyTools.ConstantVelocityDOF","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.ConstantVelocityDOF","text":"ConstantVelocityDOF(ẋ0::Float64) <: AbstractPrescribedDOFKinematics\n\nSet kinematics with constant velocity ẋ0.\n\n\n\n\n\n","category":"type"},{"location":"manual/dofmotions/#RigidBodyTools.OscillatoryDOF","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.OscillatoryDOF","text":"OscillatoryDOF(amp,angfreq,phase,ẋ0) <: AbstractPrescribedDOFKinematics\n\nSet sinusoidal kinematics with amplitude amp, angular frequency angfreq, phase phase, and mean velocity ẋ0. The function it provides is x(t) = ẋ0*t + amp*sin(angfreq*t+phase).\n\n\n\n\n\n","category":"type"},{"location":"manual/dofmotions/#RigidBodyTools.SmoothRampDOF","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.SmoothRampDOF","text":"SmoothRampDOF(ẋ0,Δx,t0[;ramp=EldredgeRamp(11.0)]) <: AbstractPrescribedDOFKinematics\n\nKinematics describing a smooth ramp change in position Δx starting at time t0 with nominal rate ẋ0. Note that the sign of ẋ0 should be the same as the sign of Δx, and will be automatically changed if they differ. The optional ramp argument is assumed to be given by the smooth ramp EldredgeRamp with a smoothness factor of 11 (larger values lead to sharper transitions on/off the ramp), but this can be replaced by another Eldredge ramp with a different value or a ColoniusRamp.\n\n\n\n\n\n","category":"type"},{"location":"manual/dofmotions/#RigidBodyTools.SmoothVelocityRampDOF","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.SmoothVelocityRampDOF","text":"SmoothVelocityRampDOF(ẍ0,ẋ1,ẋ2,t0[;ramp=EldredgeRamp(11.0)]) <: AbstractPrescribedDOFKinematics\n\nKinematics describing a smooth ramp change in velocity from ẋ1 to ẋ2 starting at time t0 with nominal acceleration ẍ0. Note that the sign of ẍ0 should be the same as the sign of ẋ2-ẋ1, and will be automatically changed if they differ. The optional ramp argument is assumed to be given by the smooth ramp EldredgeRamp with a smoothness factor of 11 (larger values lead to sharper transitions on/off the ramp), but this can be replaced by another Eldredge ramp with a different value.\n\n\n\n\n\n","category":"type"},{"location":"manual/dofmotions/#RigidBodyTools.CustomDOF","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.CustomDOF","text":"CustomDOF(f::Function) <: AbstractPrescribedDOFKinematics\n\nSet custom kinematics for a degree of freedom with a function f that specifies its value at any given time.\n\n\n\n\n\n","category":"type"},{"location":"manual/dofmotions/#RigidBodyTools.ExogenousDOF","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.ExogenousDOF","text":"ExogenousDOF() <: AbstractDOFKinematics\n\nSets a DOF as constrained, but with its behavior set by an exogenous process at every instant. For such a DOF, one must provide a vector  [x,ẋ,ẍ].\n\n\n\n\n\n","category":"type"},{"location":"manual/dofmotions/#RigidBodyTools.UnconstrainedDOF","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.UnconstrainedDOF","text":"UnconstrainedDOF([f::Function]) <: AbstractDOFKinematics\n\nSets a DOF as unconstrained, so that its behavior is either completely free or determined by a given force response (e.g., spring and/or damper). This force response is set by the optional input function f. The signature of f must be f(x,xdot,t), where x and xdot are the position of the dof and its derivative, respectively, and t is the current time. It must return a single scalar, serving as a force or torque for that DOF.\n\n\n\n\n\n","category":"type"},{"location":"manual/dofmotions/#RigidBodyTools.dof_position","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.dof_position","text":"dof_position(kd::DOFKinematicData) -> Float64\n\nReturns the position of the given kinematic data of the degree of freedom\n\n\n\n\n\n","category":"function"},{"location":"manual/dofmotions/#RigidBodyTools.dof_velocity","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.dof_velocity","text":"dof_velocity(kd::DOFKinematicData) -> Float64\n\nReturns the velocity of the given kinematic data of the degree of freedom\n\n\n\n\n\n","category":"function"},{"location":"manual/dofmotions/#RigidBodyTools.dof_acceleration","page":"Behaviors of degrees of freedom","title":"RigidBodyTools.dof_acceleration","text":"dof_acceleration(kd::DOFKinematicData) -> Float64\n\nReturns the acceleration of the given kinematic data of the degree of freedom\n\n\n\n\n\n","category":"function"}]
}
