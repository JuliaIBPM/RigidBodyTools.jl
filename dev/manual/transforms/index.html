<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Plucker vectors and coordinate transforms · RigidBodyTools.jl</title><meta name="title" content="Plucker vectors and coordinate transforms · RigidBodyTools.jl"/><meta property="og:title" content="Plucker vectors and coordinate transforms · RigidBodyTools.jl"/><meta property="twitter:title" content="Plucker vectors and coordinate transforms · RigidBodyTools.jl"/><meta name="description" content="Documentation for RigidBodyTools.jl."/><meta property="og:description" content="Documentation for RigidBodyTools.jl."/><meta property="twitter:description" content="Documentation for RigidBodyTools.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RigidBodyTools.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Bodies and Transforms</span><ul><li><a class="tocitem" href="../shapes/">Creating bodies</a></li><li class="is-active"><a class="tocitem" href>Plucker vectors and coordinate transforms</a><ul class="internal"><li><a class="tocitem" href="#Plücker-vectors"><span>Plücker vectors</span></a></li><li><a class="tocitem" href="#Transforms"><span>Transforms</span></a></li><li><a class="tocitem" href="#Transforming-bodies"><span>Transforming bodies</span></a></li><li><a class="tocitem" href="#Transforming-Plücker-vectors"><span>Transforming Plücker vectors</span></a></li><li><a class="tocitem" href="#Transform-functions"><span>Transform functions</span></a></li></ul></li><li><a class="tocitem" href="../bodylists/">Lists of bodies and their transforms</a></li></ul></li><li><span class="tocitem">Motions</span><ul><li><a class="tocitem" href="../dofmotions/">Behaviors of degrees of freedom</a></li><li><a class="tocitem" href="../joints/">Joints and body-joint systems</a></li><li><a class="tocitem" href="../exogenous/">Exogenous degrees of freedom</a></li><li><a class="tocitem" href="../deformation/">Deforming bodies</a></li><li><a class="tocitem" href="../surfacevelocities/">Evaluating velocities on body surfaces</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Bodies and Transforms</a></li><li class="is-active"><a href>Plucker vectors and coordinate transforms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Plucker vectors and coordinate transforms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/RigidBodyTools.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/master/test/literate/transforms.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Plucker-vectors-and-coordinate-transforms"><a class="docs-heading-anchor" href="#Plucker-vectors-and-coordinate-transforms">Plucker vectors and coordinate transforms</a><a id="Plucker-vectors-and-coordinate-transforms-1"></a><a class="docs-heading-anchor-permalink" href="#Plucker-vectors-and-coordinate-transforms" title="Permalink"></a></h1><p>Here we discuss the use of Plücker vectors and their transforms for describing rigid-body motion and force. Plücker vectors succinctly describe both the angular (rotational) and linear (translational) part of motion, and the angular (moment) and linear (force) part of force. In three dimensions, a Plücker vector is 6-dimensional, e.g., Plücker velocity and force vectors are</p><p class="math-container">\[v = \begin{bmatrix} \Omega_x \\ \Omega_y \\ \Omega_z \\ U_x \\ U_y \\ U_z \end{bmatrix}, \qquad
f = \begin{bmatrix} M_x \\ M_y \\ M_z \\ F_x \\ F_y \\ F_z \end{bmatrix}\]</p><p>In two dimensions, there is only one angular component and two linear components, e.g.,</p><p class="math-container">\[v = \begin{bmatrix} \Omega_z \\ U_x \\ U_y \end{bmatrix}, \qquad f = \begin{bmatrix} M_z \\ F_x \\ F_y \end{bmatrix}\]</p><p>We need to be able to transform these vectors from one coordinate system to another. This requires rotating their components and shifting their center from one origin to another. For example, a translational velocity based at system B will be different from the translational velocity at system A because of the rotational velocity, <span>$\Omega \times {}^Br_{A}$</span>, where <span>${}^Br_{A}$</span> is the vector from the origin of A to the origin of B.</p><p>Similarly, the moment about B will be different from the moment about A due to the moment arm <span>${}^Br_{A} \times F$</span>.</p><pre><code class="language-julia hljs">using RigidBodyTools
using LinearAlgebra
using Plots</code></pre><h2 id="Plücker-vectors"><a class="docs-heading-anchor" href="#Plücker-vectors">Plücker vectors</a><a id="Plücker-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Plücker-vectors" title="Permalink"></a></h2><p>A Plücker vector is easily created by simply supplying a vector of its components</p><pre><code class="language-julia hljs">v = PluckerMotion([1.0,2.0,3.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2d Plucker motion vector, Ω = 1.0, U = [2.0, 3.0]</code></pre><p>This created a 2d motion vector, with angular velocity 1.0 and linear velocity (2.0,3.0). One can also supply the angular and linear parts separately, using keywords. If one of these keywords is omitted, it defaults to zero for that part. Note that we also need to write this as <code>PluckerMotion{2}</code> to specify the physical dimensionality. For a 3d motion vector, one would write <code>PluckerMotion{3}</code> here.</p><pre><code class="language-julia hljs">v2 = PluckerMotion{2}(angular=1.0,linear=[2.0,3.0])
v2 == v</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>We can also pick off the angular and linear parts</p><pre><code class="language-julia hljs">angular_only(v)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PluckerMotionAngular{2}(2d Plucker motion vector, Ω = 1.0, U = [2.0, 3.0])</code></pre><p>and</p><pre><code class="language-julia hljs">linear_only(v)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PluckerMotionLinear{2}(2d Plucker motion vector, Ω = 1.0, U = [2.0, 3.0])</code></pre><p>Force vectors are similar</p><pre><code class="language-julia hljs">f = PluckerForce([-1.0,-3.5,2.25])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2d Plucker force vector, M = -1.0, F = [-3.5, 2.25]</code></pre><p>The vectors of the same type can be added and subtracted</p><pre><code class="language-julia hljs">v3 = v + v2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2d Plucker motion vector, Ω = 2.0, U = [4.0, 6.0]</code></pre><p>We can also take a scalar product of force and motion vectors</p><pre><code class="language-julia hljs">dot(f,v)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-1.25</code></pre><h2 id="Transforms"><a class="docs-heading-anchor" href="#Transforms">Transforms</a><a id="Transforms-1"></a><a class="docs-heading-anchor-permalink" href="#Transforms" title="Permalink"></a></h2><p>Transforms are constructed by describing the relationship between the two coordinate systems. Consider the example in the figure below.</p><p><img src="../assets/CoordinateSystems.svg" alt="CoordinateSystems.svg"/></p><p>To develop the 2d transform from A to B, we supply the position <span>$r$</span> and the rotation angle <span>$\theta$</span>. For example, if B is shifted by [1,1] and rotated by angle <span>$\pi/6$</span> counterclockwise about A, then we construct the transform as</p><pre><code class="language-julia hljs">Xm = MotionTransform([1,1],π/6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2d motion transform, x = [1.0, 1.0], R = [0.8660254037844387 0.49999999999999994; -0.49999999999999994 0.8660254037844387]</code></pre><p>Note that it uses the angle of rotation, <span>$\pi/6$</span>, to create a rotation matrix operator.</p><p>A 2d force transform would be constructed by</p><pre><code class="language-julia hljs">Xf = ForceTransform([1,1],π/6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2d force transform, x = [1.0, 1.0], R = [0.8660254037844387 0.49999999999999994; -0.49999999999999994 0.8660254037844387]</code></pre><p>For 3d transforms, we need to supply the rotation operator itself (as well as the 3d translation vector). Often, this rotation is done by rotating about a certain axis by a certain angle. We do this with the <code>rotation_about_axis</code> function. For example, to rotate by <span>$\pi/4$</span> about an axis parallel to the vector <span>$[1,1,1]$</span>, then we use</p><pre><code class="language-julia hljs">R = rotation_about_axis(π/4,[1,1,1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 StaticArraysCore.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  0.804738  -0.310617   0.505879
  0.505879   0.804738  -0.310617
 -0.310617   0.505879   0.804738</code></pre><p>and then to translate this rotated system by <span>$[-1,-2,-3]$</span>,</p><pre><code class="language-julia hljs">Xm = MotionTransform([-1,-2,-3],R)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3d motion transform, x = [-1, -2, -3], R = [0.8047378541243648 -0.31061721752604554 0.5058793634016806; 0.5058793634016806 0.8047378541243648 -0.31061721752604554; -0.31061721752604554 0.5058793634016806 0.8047378541243648]</code></pre><p>and similarly for a force transform.</p><p>We can also compute the inverses of these transforms, to transform back from B to A</p><pre><code class="language-julia hljs">inv(Xm)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3d motion transform, x = [1.7011415092773154, 1.1835034190722735, 3.11535507165041], R = [0.8047378541243648 0.5058793634016806 -0.31061721752604554; -0.31061721752604554 0.8047378541243648 0.5058793634016806; 0.5058793634016806 -0.31061721752604554 0.8047378541243648]</code></pre><p>Transforms of the same type (motion or force) can be composed via multiplication to transform from, e.g., A to B to C.</p><pre><code class="language-julia hljs">Xm1 = MotionTransform([1.5,1.5],π/6)
Xm2 = MotionTransform([-1,1],π/3)
Xm2*Xm1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2d motion transform, x = [0.1339745962155614, 1.8660254037844388], R = [2.1460752085336256e-16 1.0; -1.0 2.1460752085336256e-16]</code></pre><h2 id="Transforming-bodies"><a class="docs-heading-anchor" href="#Transforming-bodies">Transforming bodies</a><a id="Transforming-bodies-1"></a><a class="docs-heading-anchor-permalink" href="#Transforming-bodies" title="Permalink"></a></h2><p>We can use motion transforms, in particular, to place bodies. We simply apply the transform as a function, and it transforms the body&#39;s coordinates. For example, transform <code>Xm1</code> above shifts the body to <code>[1.5,1.5]</code> and rotates it counterclockwise by <code>π/6</code>:</p><pre><code class="language-julia hljs">b = Ellipse(1.0,0.2,0.02)
plot(b,xlims=(-3,3),ylims=(-3,3),fillcolor=:gray)
plot!(Xm1(b),xlims=(-3,3),ylims=(-3,3))</code></pre><img src="4e21d225.svg" alt="Example block output"/><p>In the example above, we did not affect the original body by applying the transform as a function. Rather, we created a copy of the body.</p><p>If, instead, you wish to transform the body in place, use <code>update_body!</code></p><pre><code class="language-julia hljs">update_body!(b,Xm1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Elliptical body with 208 points and semi-axes (1.0,0.2)
   Current position: (1.5,1.5)
   Current angle (rad): 0.5235987755982987
</code></pre><p>One important note: a body stores a set of coordinates in its own intrinsic coordinate system, and when a transform is applied to the body, it always acts on these coordinates. This means that the transform&#39;s application on the body cannot be carried out as a composite of operations, e.g. <code>T2(T1(b))</code> is not possible. Insteady, in the application on the body, the transform is always interpreted such that system A is the inertial coordinate system and B is the body system. Of course, the transform itself can always be constructed from composite transforms.</p><p>Sometimes we need information about the normals in the body system. For these, we can use <code>normalmid</code> with the flag <code>axes=:body</code>:</p><pre><code class="language-julia hljs">nx, ny = normalmid(b,axes=:body)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([1.0000000000000002, 0.886335337801729, 0.7369383257078719, 0.6074921092237509, 0.5315356836790487, 0.46002086938081577, 0.4196286225913622, 0.37383679538157694, 0.3490372105915698, 0.3162175178317445  …  0.29937695843692386, 0.3162178254216906, 0.3490368976183922, 0.37383710310484886, 0.4196283157312741, 0.460021163993197, 0.5315354051225997, 0.6074923550501666, 0.7369381416992703, 0.886335424329191], [-0.0, 0.46304391688468227, 0.6759599870575563, 0.7943257123062704, 0.8470359006416734, 0.8879081032033317, 0.9076958847004369, 0.9274945015571872, 0.9371088654059572, 0.9486867140507002  …  -0.9541349153851568, -0.9486866115243676, -0.9371089819764412, -0.9274943775259097, -0.9076960265620437, -0.8879079505660217, -0.8470360754425852, -0.7943255243006957, -0.6759601876655473, -0.46304375125812297])</code></pre><p>Finally, if you wish to transform the body&#39;s own coordinate system, rather than use the transform to simply place the body in the inertial system, then use <code>transform_body!</code>. This transforms the intrinsic coordinates of the body.</p><pre><code class="language-julia hljs">transform_body!(b,Xm1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Elliptical body with 208 points and semi-axes (1.0,0.2)
   Current position: (1.5,1.5)
   Current angle (rad): 0.5235987755982987
</code></pre><h2 id="Transforming-Plücker-vectors"><a class="docs-heading-anchor" href="#Transforming-Plücker-vectors">Transforming Plücker vectors</a><a id="Transforming-Plücker-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Transforming-Plücker-vectors" title="Permalink"></a></h2><p>Transforms can be applied to Plücker vectors to transform their components between systems. Let&#39;s consider a 2d example in which the motion based at system A is purely a rotation with angular velocity <span>$\Omega = 1$</span>, and we wish to transform this to system B, translated by <span>$[2,0]$</span> from A, but with axes aligned with B. We expect that the velocity based at B should have the same angular velocity, but also should have translational velocity equal to <span>$[0,2]$</span> due to the angular motion.</p><p>First we construct the motion vector at A</p><pre><code class="language-julia hljs">Ω = 1.0
vA = PluckerMotion(Ω,[0,0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2d Plucker motion vector, Ω = 1.0, U = [0.0, 0.0]</code></pre><p>Now construct the transform from A to B:</p><pre><code class="language-julia hljs">XA_to_B = MotionTransform([2,0],0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2d motion transform, x = [2.0, 0.0], R = [1.0 -0.0; 0.0 1.0]</code></pre><p>Now apply the transform to get the velocity at B:</p><pre><code class="language-julia hljs">vB = XA_to_B*vA</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2d Plucker motion vector, Ω = 1.0, U = [0.0, 2.0]</code></pre><p>which gives the expected result. Now let&#39;s transform back, using the inverse, and check that we get back to <code>vA</code></p><pre><code class="language-julia hljs">inv(XA_to_B)*vB</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2d Plucker motion vector, Ω = 1.0, U = [0.0, 0.0]</code></pre><h2 id="Transform-functions"><a class="docs-heading-anchor" href="#Transform-functions">Transform functions</a><a id="Transform-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Transform-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RigidBodyTools.PluckerMotion" href="#RigidBodyTools.PluckerMotion"><code>RigidBodyTools.PluckerMotion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PluckerMotion(data::AbstractVector)</code></pre><p>Creates an instance of a Plucker motion vector,</p><p><span>$v = \begin{bmatrix} \Omega \\ U \end{bmatrix}$</span></p><p>using the vector in <code>data</code>. If <code>data</code> is of length 6, then it creates a 3d motion vector, and the first 3 entries are assumed to comprise the rotational component <code>\Omega</code> and the last 3 entries the translational component <code>U</code>. If <code>data</code> is of length 3, then it creates a 2d motion vector, assuming that the first entry in <code>data</code> represents the rotational component and the second and third entries the x and y translational components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L30-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RigidBodyTools.PluckerForce" href="#RigidBodyTools.PluckerForce"><code>RigidBodyTools.PluckerForce</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PluckerForce(data::AbstractVector)</code></pre><p>Creates an instance of a Plucker force vector,</p><p><span>$f = \begin{bmatrix} M \\ F \end{bmatrix}$</span></p><p>using the vector in <code>data</code>. If <code>data</code> is of length 6, then it creates a 3d force vector, and the first 3 entries are assumed to comprise the moment component <code>M</code> and the last 3 entries the force component <code>F</code>. If <code>data</code> is of length 3, then it creates a 2d force vector, assuming that the first entry in <code>data</code> represents the moment component and the second and third entries the x and y force components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L46-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RigidBodyTools.angular_only" href="#RigidBodyTools.angular_only"><code>RigidBodyTools.angular_only</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">angular_only(v::AbstractPluckerVector)</code></pre><p>Returns a Plucker vector with only the angular part of the motion or force vector <code>v</code> available for subsequent operations. Note that no copy of the original data in <code>v</code> is made. Rather, this simply provides a lazy reference to the angular data in <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L171-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RigidBodyTools.linear_only" href="#RigidBodyTools.linear_only"><code>RigidBodyTools.linear_only</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_only(v::AbstractPluckerVector)</code></pre><p>Returns a Plucker vector with only the linear part of the motion or force vector <code>v</code> available for subsequent operations. Note that no copy of the original data in <code>v</code> is made. Rather, this simply provides a lazy reference to the linear data in <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L180-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot-Tuple{RigidBodyTools.AbstractPluckerForceVector, RigidBodyTools.AbstractPluckerMotionVector}" href="#LinearAlgebra.dot-Tuple{RigidBodyTools.AbstractPluckerForceVector, RigidBodyTools.AbstractPluckerMotionVector}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dot(f::AbstractPluckerForceVector,v::AbstractPluckerMotionVector) -&gt; Real</code></pre><p>Calculate the scalar product between force <code>f</code> and motion <code>v</code>. The commutation of this is also possible, <code>dot(v,f)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L191-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RigidBodyTools.MotionTransform" href="#RigidBodyTools.MotionTransform"><code>RigidBodyTools.MotionTransform</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(T::MotionTransform)(b::Body) -&gt; Body</code></pre><p>Transforms a body <code>b</code> using the given <code>MotionTransform</code>, creating a copy of this body with the new configuration. In using this transform <code>T</code> (which defines a transform from system A to system B), A is interpreted as an inertial coordinate system and B as the body system. Thus, the position vector in <code>T</code> is interpreted as the relative position of the body in inertial coordinates and the inverse of the rotation operator is applied to transform body-fixed coordinates to the inertial frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L352-L361">source</a></section><section><div><pre><code class="language-julia hljs">MotionTransform(xA_to_B::SVector,RA_to_B::SMatrix) -&gt; MotionTransform</code></pre><p>Computes the Plucker transform matrix for motion vectors, transforming from system A to system B. The input <code>xA_to_B</code> is the Euclidean vector from the origin of A to the origin of B, expressed in A coordinates, and <code>RA_to_B</code> is the rotation matrix transforming coordinates in system A to those in system B. The resulting matrix has the form</p><p><span>${}^B T^{(m)}_A = \begin{bmatrix} R &amp; 0 \\ 0 &amp; R \end{bmatrix} \begin{bmatrix} 1 &amp; 0 \\ -x^\times &amp; 1 \end{bmatrix}$</span></p><p>One can also provide <code>xA_to_B</code> as a standard vector and <code>RA_to_B</code> as a standard 3 x 3 matrix.</p><p>If <code>xA_to_B</code> has length 3, then a three-dimensional transform (a 6 x 6 Plucker transform) is created. If <code>xA_to_B</code> has length 2, then a two-dimensional transform (3 x 3 Plucker transform) is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L543-L559">source</a></section><section><div><pre><code class="language-julia hljs">MotionTransform(xA_to_B,θ::Real) -&gt; MotionTransform</code></pre><p>Computes the 3 x 3 2D Plucker transform matrix for motion vectors, transforming from system A to system B. The input <code>xA_to_B</code> is the 2-d Euclidean vector from the origin of A to the origin of B, expressed in A coordinates, and <code>θ</code> is the angle of system B relative to system A. <code>xA_to_B</code> can be in the form of a static vector, a vector, or a tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L562-L570">source</a></section><section><div><pre><code class="language-julia hljs">MotionTransform(T::RigidTransform) -&gt; MotionTransform</code></pre><p>Computes the 3 x 3 2D Plucker transform matrix for motion vectors, transforming from system A to system B, from the rigid transform <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L572-L577">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RigidBodyTools.ForceTransform" href="#RigidBodyTools.ForceTransform"><code>RigidBodyTools.ForceTransform</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ForceTransform(xA_to_B::SVector,RA_to_B::SMatrix) -&gt; ForceTransform</code></pre><p>Computes the 6 x 6 Plucker transform matrix for force vectors, transforming from system A to system B. The input <code>xA_to_B</code> is the Euclidean vector from the origin of A to the origin of B, expressed in A coordinates, and <code>RA_to_B</code> is the rotation matrix transforming coordinates in system A to those in system B. The resulting matrix has the form</p><p><span>${}^B T^{(f)}_A = \begin{bmatrix} R &amp; 0 \\ 0 &amp; R \end{bmatrix} \begin{bmatrix} 1 &amp; -x^\times \\ 0 &amp; 1 \end{bmatrix}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L580-L589">source</a></section><section><div><pre><code class="language-julia hljs">ForceTransform(xA_to_B,θ::Real) -&gt; ForceTransform</code></pre><p>Computes the 3 x 3 2D Plucker transform matrix for force vectors, transforming from system A to system B. The input <code>xA_to_B</code> is the 2-d Euclidean vector from the origin of A to the origin of B, expressed in A coordinates, and <code>θ</code> is the angle of system B relative to system A. <code>xA_to_B</code> can be in the form of a static vector, a vector, or a tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L591-L599">source</a></section><section><div><pre><code class="language-julia hljs">ForceTransform(T::RigidTransform) -&gt; ForceTransform</code></pre><p>Computes the 3 x 3 2D Plucker transform matrix for force vectors, transforming from system A to system B, from the rigid transform <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L601-L606">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.inv-Tuple{AbstractTransformOperator}" href="#Base.inv-Tuple{AbstractTransformOperator}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inv(M)</code></pre><p>Matrix inverse. Computes matrix <code>N</code> such that <code>M * N = I</code>, where <code>I</code> is the identity matrix. Computed by solving the left-division <code>N = M \ I</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = [2 5; 1 3]
2×2 Matrix{Int64}:
 2  5
 1  3

julia&gt; N = inv(M)
2×2 Matrix{Float64}:
  3.0  -5.0
 -1.0   2.0

julia&gt; M*N == N*M == Matrix(I, 2, 2)
true</code></pre></div></section><section><div><pre><code class="language-julia hljs">inv(X::AbstractTransformOperator) -&gt; AbstractTransformOperator</code></pre><p>Return the inverse of the motion or force transform <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L300-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.transpose-Tuple{AbstractTransformOperator}" href="#Base.transpose-Tuple{AbstractTransformOperator}"><code>Base.transpose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transpose(X::MotionTransform) -&gt; ForceTransform
transpose(X::ForceTransform) -&gt; MotionTransform</code></pre><p>For a motion transform <code>X</code> mapping from system A to B, returns the force transform mapping from B to A. Alternatively, if <code>X</code> is a force transform, it returns the motion transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L283-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RigidBodyTools.rotation_transform" href="#RigidBodyTools.rotation_transform"><code>RigidBodyTools.rotation_transform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotation_transform(T::AbstractTransformOperator) -&gt; AbstractTransformOperator</code></pre><p>Returns a transform operator consisting of only the rotational part of <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L311-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RigidBodyTools.translation_transform" href="#RigidBodyTools.translation_transform"><code>RigidBodyTools.translation_transform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translation_transform(T::AbstractTransformOperator) -&gt; AbstractTransformOperator</code></pre><p>Returns a transform operator consisting of only the translational part of <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RigidBodyTools.update_body!" href="#RigidBodyTools.update_body!"><code>RigidBodyTools.update_body!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_body!(b::Body,T::MotionTransform)</code></pre><p>Transforms a body (in-place) using the given <code>MotionTransform</code>. In using this transform <code>T</code> (which defines a transform from system A to system B), A is interpreted as an inertial coordinate system and B as the body system. Thus, the position vector in <code>T</code> is interpreted as the relative position of the body in inertial coordinates and the inverse of the rotation operator is applied to transform body-fixed coordinates to the inertial frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L367-L375">source</a></section><section><div><pre><code class="language-julia hljs">update_body!(bl::BodyList,tl::MotionTransformList) -&gt; BodyList</code></pre><p>Carry out in-place transformations of each body in <code>bl</code> with the corresponding transformation in <code>tl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/lists.jl#L206-L211">source</a></section><section><div><pre><code class="language-julia hljs">update_body!(bl::Union{Body,BodyList},x::AbstractVector,m::RigidBodyMotion)</code></pre><p>Update body/bodies in <code>bl</code> with the rigid-body motion <code>m</code> and state vector <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidbodymotions.jl#L703-L707">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RigidBodyTools.transform_body!" href="#RigidBodyTools.transform_body!"><code>RigidBodyTools.transform_body!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transform_body!(b::Body,T::MotionTransform)</code></pre><p>Transforms a body&#39;s own coordinate system (in-place) using the given <code>MotionTransform</code>. This function differs from <a href="#RigidBodyTools.update_body!"><code>update_body!</code></a> because it changes the coordinates of the body in its own coordinate system, whereas the latter function only changes the inertial coordinates of the body. <code>T</code> is interpreted as a transform from the new system to the old system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidtransform.jl#L389-L397">source</a></section><section><div><pre><code class="language-julia hljs">transform_body!(bl::BodyList,tl::MotionTransformList) -&gt; BodyList</code></pre><p>Carry out in-place transformations of body coordinate systems for each body in <code>bl</code> with the corresponding transformation in <code>tl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/lists.jl#L217-L222">source</a></section><section><div><pre><code class="language-julia hljs">update_body!(bl::Union{Body,BodyList},x::AbstractVector,m::RigidBodyMotion)</code></pre><p>Transform body/bodies in <code>bl</code> with the rigid-body motion <code>m</code> and state vector <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/RigidBodyTools.jl/blob/9d8606b8b76f1ba01173236cbc85374e7e56f80f/src/rigidbodymotions.jl#L727-L731">source</a></section></article><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../shapes/">« Creating bodies</a><a class="docs-footer-nextpage" href="../bodylists/">Lists of bodies and their transforms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Friday 25 April 2025 18:23">Friday 25 April 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
